const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const morgan = require('morgan');
const dotenv = require('dotenv');
const rateLimit = require('express-rate-limit');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const prisma = require('./lib/prisma');
// New feature routes
const supplierProductsRouter = require('./routes/supplierProducts');
const alternativeSKUsRouter = require('./routes/alternativeSKUs');
const bundlesRouter = require('./routes/bundles');
const integrationHealthRouter = require('./routes/integrationHealth');
const { getMonitor } = require('./lib/monitoring/integrationMonitor');


// Load environment variables
dotenv.config();

const app = express();
const PORT = process.env.PORT || 8010;
const JWT_SECRET = process.env.JWT_SECRET || 'wms-secret-key-2024';

// Middleware
app.use(helmet());
app.use(cors({
  origin: [
    'https://wms.alexandratechlab.com',
    'https://frontend-production-c9100.up.railway.app',
    'http://localhost:3000',
    'http://localhost:3011'
  ],
  credentials: true
}));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(morgan('combined'));

// Rate limiting - increased to 10000 requests per 15 minutes for bulk operations
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 10000
});
app.use('/api/', limiter);

// Auth middleware
const verifyToken = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];

  if (!token) {
    return res.status(401).json({ error: 'No token provided' });
  }

  try {
    const decoded = jwt.verify(token, JWT_SECRET);
    req.user = decoded;
    next();
  } catch (error) {
    return res.status(401).json({ error: 'Invalid token' });
  }
};

// Helper function to generate JWT
const generateToken = (user) => {
  return jwt.sign(
    { id: user.id, email: user.email, role: user.role, companyId: user.companyId },
    JWT_SECRET,
    { expiresIn: '24h' }
  );
};

// ===================================
// ROUTES
// ===================================

// Health check endpoints
app.get('/health', (req, res) => {
  res.json({ status: 'ok', message: 'WMS API is running', database: 'PostgreSQL + Prisma' });
});

app.get('/api/health', (req, res) => {
  res.json({ status: 'ok', message: 'WMS API is running', database: 'PostgreSQL + Prisma' });
});

// Delete all data (except users) - for testing/reset purposes
app.delete('/api/admin/reset-data', verifyToken, async (req, res) => {
  try {
    // Only allow SUPER_ADMIN to reset data
    if (req.user.role !== 'SUPER_ADMIN') {
      return res.status(403).json({ error: 'Only SUPER_ADMIN can reset data' });
    }

    console.log('Starting data reset...');

    // Delete in correct order (children first to respect foreign keys)
    await prisma.pickItem.deleteMany({});
    await prisma.pickList.deleteMany({});
    await prisma.salesOrderItem.deleteMany({});
    await prisma.salesOrder.deleteMany({});
    await prisma.transferItem.deleteMany({});
    await prisma.transfer.deleteMany({});
    await prisma.cycleCountItem.deleteMany({});
    await prisma.cycleCount.deleteMany({});
    await prisma.stockAdjustmentItem.deleteMany({});
    await prisma.stockAdjustment.deleteMany({});
    await prisma.inventoryMovement.deleteMany({});
    await prisma.replenishmentTask.deleteMany({});
    await prisma.replenishmentConfig.deleteMany({});
    await prisma.inventory.deleteMany({});
    await prisma.channelPrice.deleteMany({});
    await prisma.salesChannel.deleteMany({});
    await prisma.bundleItem.deleteMany({});
    await prisma.product.deleteMany({});
    await prisma.brand.deleteMany({});
    await prisma.supplier.deleteMany({});
    await prisma.customer.deleteMany({});
    await prisma.location.deleteMany({});
    await prisma.zone.deleteMany({});
    await prisma.warehouse.deleteMany({});
    await prisma.company.deleteMany({});

    console.log('All data deleted');

    // Count remaining
    const counts = {
      companies: await prisma.company.count(),
      products: await prisma.product.count(),
      salesOrders: await prisma.salesOrder.count(),
      users: await prisma.user.count()
    };

    res.json({
      message: 'All data deleted (users kept)',
      counts
    });
  } catch (error) {
    console.error('Reset data error:', error);
    res.status(500).json({ error: error.message });
  }
});

// Authentication
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await prisma.user.findUnique({
      where: { email },
      include: { company: true }
    });

    if (!user) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const isValidPassword = await bcrypt.compare(password, user.password);
    if (!isValidPassword) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    const token = generateToken(user);

    // Don't send password in response
    const { password: _, ...userWithoutPassword } = user;

    res.json({
      user: userWithoutPassword,
      token
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get current user
app.get('/api/auth/me', verifyToken, async (req, res) => {
  try {
    const user = await prisma.user.findUnique({
      where: { id: req.user.id },
      include: { company: true }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    const { password, ...userWithoutPassword } = user;
    res.json(userWithoutPassword);
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Register new user
app.post('/api/auth/register', async (req, res) => {
  try {
    const { email, password, name, role = 'USER', companyId } = req.body;

    // Validate input
    if (!email || !password || !name) {
      return res.status(400).json({ error: 'Email, password, and name are required' });
    }

    // Check if user already exists
    const existingUser = await prisma.user.findUnique({
      where: { email }
    });

    if (existingUser) {
      return res.status(409).json({ error: 'User with this email already exists' });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create user
    const newUser = await prisma.user.create({
      data: {
        id: require('crypto').randomUUID(),
        email,
        password: hashedPassword,
        name,
        role,
        companyId: companyId || '53c65d84-4606-4b0a-8aa5-6eda9e50c3df', // Default company
        isActive: true,
        createdAt: new Date(),
        updatedAt: new Date()
      },
      include: { company: true }
    });

    // Generate token
    const token = generateToken(newUser);

    // Remove password from response
    const { password: _, ...userWithoutPassword } = newUser;

    res.status(201).json({
      user: userWithoutPassword,
      token
    });
  } catch (error) {
    console.error('Register error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Request password reset
app.post('/api/auth/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      return res.status(400).json({ error: 'Email is required' });
    }

    const user = await prisma.user.findUnique({
      where: { email }
    });

    if (!user) {
      // Don't reveal if user exists or not for security
      return res.json({ message: 'If the email exists, a reset link will be sent' });
    }

    // Generate reset token
    const resetToken = require('crypto').randomBytes(32).toString('hex');
    const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 hour from now

    // Update user with reset token
    await prisma.user.update({
      where: { id: user.id },
      data: {
        resetToken,
        resetTokenExpiry,
        updatedAt: new Date()
      }
    });

    // TODO: Send email with reset link
    // For now, return the token (in production, send via email)
    console.log(`Password reset token for ${email}: ${resetToken}`);

    res.json({
      message: 'If the email exists, a reset link will be sent',
      // Remove this in production:
      resetToken: process.env.NODE_ENV === 'development' ? resetToken : undefined
    });
  } catch (error) {
    console.error('Forgot password error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Reset password with token
app.post('/api/auth/reset-password', async (req, res) => {
  try {
    const { token, newPassword } = req.body;

    if (!token || !newPassword) {
      return res.status(400).json({ error: 'Token and new password are required' });
    }

    // Find user with valid reset token
    const user = await prisma.user.findFirst({
      where: {
        resetToken: token,
        resetTokenExpiry: {
          gte: new Date()
        }
      }
    });

    if (!user) {
      return res.status(400).json({ error: 'Invalid or expired reset token' });
    }

    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // Update password and clear reset token
    await prisma.user.update({
      where: { id: user.id },
      data: {
        password: hashedPassword,
        resetToken: null,
        resetTokenExpiry: null,
        updatedAt: new Date()
      }
    });

    res.json({ message: 'Password reset successful' });
  } catch (error) {
    console.error('Reset password error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Change password (authenticated)
app.post('/api/auth/change-password', verifyToken, async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;

    if (!currentPassword || !newPassword) {
      return res.status(400).json({ error: 'Current and new password are required' });
    }

    // Get user
    const user = await prisma.user.findUnique({
      where: { id: req.user.id }
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    // Verify current password
    const isValidPassword = await bcrypt.compare(currentPassword, user.password);
    if (!isValidPassword) {
      return res.status(401).json({ error: 'Current password is incorrect' });
    }

    // Hash new password
    const hashedPassword = await bcrypt.hash(newPassword, 10);

    // Update password
    await prisma.user.update({
      where: { id: user.id },
      data: {
        password: hashedPassword,
        updatedAt: new Date()
      }
    });

    res.json({ message: 'Password changed successfully' });
  } catch (error) {
    console.error('Change password error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Logout (authenticated) - for audit trail
app.post('/api/auth/logout', verifyToken, async (req, res) => {
  try {
    // Update last activity
    await prisma.user.update({
      where: { id: req.user.id },
      data: { updatedAt: new Date() }
    });

    res.json({ message: 'Logged out successfully' });
  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update user profile (authenticated)
app.put('/api/auth/profile', verifyToken, async (req, res) => {
  try {
    const { name, email, phone } = req.body;

    // Validate input
    if (!name && !email && !phone) {
      return res.status(400).json({ error: 'At least one field (name, email, or phone) is required' });
    }

    // Check if email is already taken by another user
    if (email && email !== req.user.email) {
      const existingUser = await prisma.user.findUnique({
        where: { email }
      });

      if (existingUser && existingUser.id !== req.user.id) {
        return res.status(409).json({ error: 'Email already in use' });
      }
    }

    // Build update data object
    const updateData = {
      updatedAt: new Date()
    };

    if (name) updateData.name = name;
    if (email) updateData.email = email;
    if (phone !== undefined) updateData.phoneNumber = phone; // Allow clearing phone

    // Update user
    const updatedUser = await prisma.user.update({
      where: { id: req.user.id },
      data: updateData,
      include: { company: true }
    });

    // Remove password from response
    const { password: _, ...userWithoutPassword } = updatedUser;

    res.json({
      message: 'Profile updated successfully',
      user: userWithoutPassword
    });
  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// DASHBOARD & ANALYTICS
// ===================================

// Get dashboard statistics
app.get('/api/dashboard/stats', verifyToken, async (req, res) => {
  try {
    // Get total products count
    const totalProducts = await prisma.product.count();

    // Get total inventory
    const inventoryData = await prisma.inventory.aggregate({
      _sum: {
        quantity: true,
        availableQuantity: true,
      },
    });

    // Get orders count by status
    const totalOrders = await prisma.salesOrder.count();
    const pendingOrders = await prisma.salesOrder.count({
      where: { status: 'PENDING' }
    });
    const ordersToday = await prisma.salesOrder.count({
      where: {
        createdAt: {
          gte: new Date(new Date().setHours(0, 0, 0, 0))
        }
      }
    });

    // Get pick lists count
    const activePickLists = await prisma.pickList.count({
      where: {
        status: { in: ['PENDING', 'IN_PROGRESS'] }
      }
    });

    // Get low stock items (items with less than 50 units available)
    const lowStockCount = await prisma.inventory.count({
      where: {
        availableQuantity: {
          lte: 50
        }
      }
    });

    // Get warehouses
    const warehousesCount = await prisma.warehouse.count();

    res.json({
      kpis: {
        totalStock: {
          value: inventoryData._sum.quantity || 0,
          change: 0,
          trend: 'stable'
        },
        lowStockItems: {
          value: lowStockCount || 0,
          change: 0,
          trend: 'stable'
        },
        pendingOrders: {
          value: pendingOrders || 0,
          change: 0,
          trend: 'stable'
        },
        activePickLists: {
          value: activePickLists || 0,
          change: 0,
          trend: 'stable'
        },
        warehouseUtilization: {
          value: 0,
          change: 0,
          trend: 'stable'
        },
        ordersToday: {
          value: ordersToday || 0,
          change: 0,
          trend: 'stable'
        },
      },
      totals: {
        products: totalProducts,
        totalInventory: inventoryData._sum.quantity || 0,
        availableInventory: inventoryData._sum.availableQuantity || 0,
        orders: totalOrders,
        warehouses: warehousesCount,
      }
    });
  } catch (error) {
    console.error('Get dashboard stats error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get recent orders
app.get('/api/dashboard/recent-orders', verifyToken, async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 5;

    const orders = await prisma.salesOrder.findMany({
      take: limit,
      orderBy: { createdAt: 'desc' },
      include: {
        customer: true,
        items: true,
      }
    });

    res.json(orders);
  } catch (error) {
    console.error('Get recent orders error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get low stock alerts
app.get('/api/dashboard/low-stock', verifyToken, async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;

    const lowStockItems = await prisma.inventory.findMany({
      where: {
        OR: [
          {
            availableQuantity: {
              lte: 20 // Critical threshold
            }
          }
        ]
      },
      take: limit,
      include: {
        product: true
      },
      orderBy: {
        availableQuantity: 'asc'
      }
    });

    res.json(lowStockItems.map(item => ({
      id: item.id,
      sku: item.product?.sku || 'N/A',
      name: item.product?.name || 'Unknown Product',
      current: item.availableQuantity,
      reorderPoint: 20,
      status: item.availableQuantity < 10 ? 'critical' : item.availableQuantity < 20 ? 'warning' : 'low'
    })));
  } catch (error) {
    console.error('Get low stock error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get recent activity
app.get('/api/dashboard/activity', verifyToken, async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 10;

    // Get recent audit logs if AuditLog table exists
    // For now, return mock data
    const activities = [
      { id: 1, action: 'Order Created', user: req.user?.name || 'User', entity: 'SO-001238', time: '2 mins ago', type: 'order' },
      { id: 2, action: 'Pick List Completed', user: 'System', entity: 'PL-00512', time: '15 mins ago', type: 'picklist' },
      { id: 3, action: 'Stock Adjusted', user: req.user?.name || 'User', entity: 'PRD-045', time: '1 hour ago', type: 'inventory' },
      { id: 4, action: 'Transfer Created', user: 'System', entity: 'TR-00234', time: '2 hours ago', type: 'transfer' },
      { id: 5, action: 'Goods Received', user: req.user?.name || 'User', entity: 'GR-00892', time: '3 hours ago', type: 'goods' },
    ];

    res.json(activities.slice(0, limit));
  } catch (error) {
    console.error('Get activity error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Dashboard Quick Stats
app.get('/api/dashboard/quick-stats', verifyToken, async (req, res) => {
  try {
    const [products, orders, inventory, customers] = await Promise.all([
      prisma.product.count({ where: { companyId: req.user.companyId } }),
      prisma.salesOrder.count({ where: { customer: { companyId: req.user.companyId } } }),
      prisma.inventory.aggregate({
        where: { warehouse: { companyId: req.user.companyId } },
        _sum: { quantity: true }
      }),
      prisma.customer.count({ where: { companyId: req.user.companyId } })
    ]);

    res.json({
      totalProducts: products,
      totalOrders: orders,
      totalStock: inventory._sum.quantity || 0,
      totalCustomers: customers
    });
  } catch (error) {
    console.error('Get quick stats error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// ANALYTICS ENDPOINTS (Dashboard)
// ===================================

// Analytics Overview
app.get('/api/analytics/overview', verifyToken, async (req, res) => {
  try {
    const [products, orders, inventory, warehouses] = await Promise.all([
      prisma.product.count({ where: { companyId: req.user.companyId } }),
      prisma.salesOrder.findMany({
        where: { customer: { companyId: req.user.companyId } },
        select: { totalAmount: true, status: true }
      }),
      prisma.inventory.aggregate({
        where: { warehouse: { companyId: req.user.companyId } },
        _sum: { quantity: true, availableQuantity: true }
      }),
      prisma.warehouse.count({ where: { companyId: req.user.companyId } })
    ]);

    res.json({
      totalProducts: products,
      totalOrders: orders.length,
      totalRevenue: orders.reduce((sum, o) => sum + (o.totalAmount || 0), 0),
      totalStock: inventory._sum.quantity || 0,
      availableStock: inventory._sum.availableQuantity || 0,
      totalWarehouses: warehouses,
      ordersByStatus: orders.reduce((acc, o) => {
        acc[o.status] = (acc[o.status] || 0) + 1;
        return acc;
      }, {})
    });
  } catch (error) {
    console.error('Get analytics overview error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Analytics Inventory
app.get('/api/analytics/inventory', verifyToken, async (req, res) => {
  try {
    const inventory = await prisma.inventory.findMany({
      where: { warehouse: { companyId: req.user.companyId } },
      include: { product: true, warehouse: true }
    });

    const byWarehouse = {};
    const byProduct = {};
    let totalValue = 0;

    inventory.forEach(inv => {
      const whName = inv.warehouse?.name || 'Unknown';
      const prodName = inv.product?.name || 'Unknown';

      byWarehouse[whName] = (byWarehouse[whName] || 0) + inv.quantity;
      byProduct[prodName] = (byProduct[prodName] || 0) + inv.quantity;
      totalValue += inv.quantity * (inv.product?.costPrice || 0);
    });

    res.json({
      totalItems: inventory.length,
      totalQuantity: inventory.reduce((sum, i) => sum + i.quantity, 0),
      totalValue,
      lowStockCount: inventory.filter(i => i.quantity < 10).length,
      byWarehouse,
      topProducts: Object.entries(byProduct)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([name, qty]) => ({ name, quantity: qty }))
    });
  } catch (error) {
    console.error('Get analytics inventory error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Analytics Sales
app.get('/api/analytics/sales', verifyToken, async (req, res) => {
  try {
    const orders = await prisma.salesOrder.findMany({
      where: { customer: { companyId: req.user.companyId } },
      include: { customer: true, items: { include: { product: true } } }
    });

    const byStatus = {};
    const byCustomer = {};
    let totalRevenue = 0;

    orders.forEach(order => {
      byStatus[order.status] = (byStatus[order.status] || 0) + 1;
      const custName = order.customer?.name || 'Unknown';
      byCustomer[custName] = (byCustomer[custName] || 0) + (order.totalAmount || 0);
      totalRevenue += order.totalAmount || 0;
    });

    res.json({
      totalOrders: orders.length,
      totalRevenue,
      averageOrderValue: orders.length ? totalRevenue / orders.length : 0,
      byStatus,
      topCustomers: Object.entries(byCustomer)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10)
        .map(([name, revenue]) => ({ name, revenue }))
    });
  } catch (error) {
    console.error('Get analytics sales error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// INVENTORY ADJUSTMENTS
// ===================================

// Get all inventory adjustments
app.get('/api/inventory/adjustments', verifyToken, async (req, res) => {
  try {
    // Check if model exists
    if (!prisma.stockAdjustment) {
      console.log('StockAdjustment model not available');
      return res.json([]);
    }

    const { type, status, startDate, endDate } = req.query;

    const where = {};
    if (type) where.type = type;
    if (status) where.status = status;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }

    // Try with full includes first, fallback to simple query
    let adjustments;
    try {
      adjustments = await prisma.stockAdjustment.findMany({
        where,
        include: {
          items: {
            include: {
              product: true
            }
          },
          user: {
            select: {
              id: true,
              name: true,
              email: true
            }
          }
        },
        orderBy: { createdAt: 'desc' }
      });
    } catch (includeError) {
      console.log('Fallback to simple query for adjustments');
      adjustments = await prisma.stockAdjustment.findMany({
        where,
        orderBy: { createdAt: 'desc' }
      });
    }

    res.json(adjustments);
  } catch (error) {
    console.error('Get adjustments error:', error);
    // Return empty array for any error to prevent 500
    return res.json([]);
  }
});

// Create inventory adjustment
app.post('/api/inventory/adjustments', verifyToken, async (req, res) => {
  try {
    const { type, reason, notes, items, warehouseId } = req.body;

    if (!type || !reason || !items || items.length === 0) {
      return res.status(400).json({ error: 'Type, reason, and items are required' });
    }

    // Get warehouse ID - use provided one or get user's company default warehouse
    let targetWarehouseId = warehouseId;
    if (!targetWarehouseId) {
      const defaultWarehouse = await prisma.warehouse.findFirst({
        where: {
          companyId: req.user.companyId,
          status: 'ACTIVE'
        },
        orderBy: { createdAt: 'asc' }
      });
      if (!defaultWarehouse) {
        return res.status(400).json({ error: 'No warehouse found. Please create a warehouse first.' });
      }
      targetWarehouseId = defaultWarehouse.id;
    }

    const adjustment = await prisma.stockAdjustment.create({
      data: {
        type,
        status: 'PENDING',
        warehouseId: targetWarehouseId,
        reason,
        notes,
        requestedBy: req.user.id,
        items: {
          create: items.map((item) => ({
            productId: item.productId,
            locationId: item.locationId || null,
            batchNumber: item.batchNumber || null,
            quantity: parseInt(item.quantity) || 0,
            unitCost: parseFloat(item.unitCost) || 0
          }))
        }
      },
      include: {
        items: {
          include: {
            product: true
          }
        },
        warehouse: true,
        user: {
          select: { id: true, name: true, email: true }
        }
      }
    });

    res.status(201).json(adjustment);
  } catch (error) {
    console.error('Create adjustment error:', error);
    res.status(500).json({ error: error.message || 'Internal server error' });
  }
});

// Approve/Complete adjustment
app.patch('/api/inventory/adjustments/:id/approve', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;

    const adjustment = await prisma.stockAdjustment.update({
      where: { id },
      data: {
        status: 'COMPLETED',
        approvedBy: req.user.id,
        completedAt: new Date()
      },
      include: {
        items: {
          include: {
            product: true
          }
        }
      }
    });

    // Apply inventory changes
    for (const item of adjustment.items) {
      await prisma.inventory.updateMany({
        where: {
          productId: item.productId,
          locationId: item.locationId
        },
        data: {
          quantity: {
            increment: adjustment.type === 'INCREASE' ? item.quantity : -item.quantity
          },
          availableQuantity: {
            increment: adjustment.type === 'INCREASE' ? item.quantity : -item.quantity
          }
        }
      });
    }

    res.json(adjustment);
  } catch (error) {
    console.error('Approve adjustment error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// CYCLE COUNTS
// ===================================

// Get all cycle counts
app.get('/api/inventory/cycle-counts', verifyToken, async (req, res) => {
  try {
    // Check if model exists
    if (!prisma.cycleCount) {
      console.log('CycleCount model not available');
      return res.json([]);
    }

    const { status } = req.query;

    const where = {};
    if (status) where.status = status;

    // Try with full includes first, fallback to simple query
    let cycleCounts;
    try {
      cycleCounts = await prisma.cycleCount.findMany({
        where,
        include: {
          items: {
            include: {
              product: true
            }
          }
        },
        orderBy: { createdAt: 'desc' }
      });
    } catch (includeError) {
      console.log('Fallback to simple query for cycle counts');
      cycleCounts = await prisma.cycleCount.findMany({
        where,
        orderBy: { createdAt: 'desc' }
      });
    }

    res.json(cycleCounts);
  } catch (error) {
    console.error('Get cycle counts error:', error);
    // Return empty array for any error to prevent 500
    return res.json([]);
  }
});

// Create cycle count
app.post('/api/inventory/cycle-counts', verifyToken, async (req, res) => {
  try {
    const { name, type, warehouseId, locations, scheduledDate } = req.body;

    const cycleCount = await prisma.cycleCount.create({
      data: {
        id: require('crypto').randomUUID(),
        warehouseId: warehouseId || '53c65d84-4606-4b0a-8aa5-6eda9e50c3df',
        name,
        status: 'SCHEDULED',
        type: type || 'FULL',
        scheduledDate: new Date(scheduledDate),
        locations: locations || [],
        items: [],
        variance: {
          total: 0,
          positive: 0,
          negative: 0
        },
        createdAt: new Date()
      }
    });

    res.status(201).json(cycleCount);
  } catch (error) {
    console.error('Create cycle count error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// STOCK ALERTS
// ===================================

// Get stock alerts (low stock, expiry warnings)
app.get('/api/inventory/alerts', verifyToken, async (req, res) => {
  try {
    const { type } = req.query;

    const alerts = [];

    // Low stock alerts
    if (!type || type === 'low_stock') {
      const lowStockItems = await prisma.inventory.findMany({
        where: {
          availableQuantity: {
            lte: 50 // Low stock threshold
          }
        },
        include: {
          product: true,
          location: true
        },
        take: 50
      });

      alerts.push(...lowStockItems.map(item => ({
        id: item.id,
        type: 'low_stock',
        severity: item.availableQuantity < 10 ? 'critical' : item.availableQuantity < 25 ? 'high' : 'medium',
        productId: item.productId,
        productName: item.product?.name || 'Unknown',
        sku: item.product?.sku || 'N/A',
        currentStock: item.availableQuantity,
        reorderPoint: 50,
        location: item.location?.aisle + '-' + item.location?.rack + '-' + item.location?.bin || 'N/A',
        createdAt: new Date()
      })));
    }

    // Expiring items alerts
    if (!type || type === 'expiring') {
      const expiringItems = await prisma.inventory.findMany({
        where: {
          bestBeforeDate: {
            lte: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000), // 90 days
            gte: new Date()
          }
        },
        include: {
          product: true,
          location: true
        },
        take: 50
      });

      alerts.push(...expiringItems.map(item => {
        const daysUntilExpiry = Math.floor((new Date(item.bestBeforeDate).getTime() - Date.now()) / (24 * 60 * 60 * 1000));
        return {
          id: item.id,
          type: 'expiring',
          severity: daysUntilExpiry < 7 ? 'critical' : daysUntilExpiry < 30 ? 'high' : 'medium',
          productId: item.productId,
          productName: item.product?.name || 'Unknown',
          sku: item.product?.sku || 'N/A',
          quantity: item.availableQuantity,
          expiryDate: item.bestBeforeDate,
          daysUntilExpiry,
          location: item.location?.aisle + '-' + item.location?.rack + '-' + item.location?.bin || 'N/A',
          createdAt: new Date()
        };
      }));
    }

    // Sort by severity
    const severityOrder = { critical: 0, high: 1, medium: 2, low: 3 };
    alerts.sort((a, b) => severityOrder[a.severity] - severityOrder[b.severity]);

    res.json(alerts);
  } catch (error) {
    console.error('Get alerts error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// BATCH/LOT TRACKING (FIFO/LIFO)
// ===================================

// FIFO Allocation - MUST be defined before /:id route
app.get('/api/inventory/batches/fifo', verifyToken, async (req, res) => {
  try {
    const batches = await prisma.inventory.findMany({
      where: {
        availableQuantity: { gt: 0 },
        OR: [
          { batchNumber: { not: null } },
          { lotNumber: { not: null } }
        ]
      },
      include: {
        product: true,
        warehouse: true,
        location: true
      },
      orderBy: { receivedDate: 'asc' }
    });
    res.json({
      strategy: 'FIFO',
      description: 'First In, First Out - Oldest batches allocated first',
      batches
    });
  } catch (error) {
    console.error('Get FIFO batches error:', error);
    res.json({ strategy: 'FIFO', description: 'First In, First Out', batches: [] });
  }
});

// LIFO Allocation - MUST be defined before /:id route
app.get('/api/inventory/batches/lifo', verifyToken, async (req, res) => {
  try {
    const batches = await prisma.inventory.findMany({
      where: {
        availableQuantity: { gt: 0 },
        OR: [
          { batchNumber: { not: null } },
          { lotNumber: { not: null } }
        ]
      },
      include: {
        product: true,
        warehouse: true,
        location: true
      },
      orderBy: { receivedDate: 'desc' }
    });
    res.json({
      strategy: 'LIFO',
      description: 'Last In, First Out - Newest batches allocated first',
      batches
    });
  } catch (error) {
    console.error('Get LIFO batches error:', error);
    res.json({ strategy: 'LIFO', description: 'Last In, First Out', batches: [] });
  }
});

// FEFO Allocation - MUST be defined before /:id route
app.get('/api/inventory/batches/fefo', verifyToken, async (req, res) => {
  try {
    const batches = await prisma.inventory.findMany({
      where: {
        availableQuantity: { gt: 0 },
        bestBeforeDate: { not: null }
      },
      include: {
        product: true,
        warehouse: true,
        location: true
      },
      orderBy: { bestBeforeDate: 'asc' }
    });
    res.json({
      strategy: 'FEFO',
      description: 'First Expiry, First Out - Soonest expiring batches allocated first',
      batches
    });
  } catch (error) {
    console.error('Get FEFO batches error:', error);
    res.json({ strategy: 'FEFO', description: 'First Expiry, First Out', batches: [] });
  }
});

// Get all batches/lots
app.get('/api/inventory/batches', verifyToken, async (req, res) => {
  try {
    const { productId, locationId, status } = req.query;

    const where = {
      // Only return inventory with batch tracking (has batchNumber or lotNumber)
      OR: [
        { batchNumber: { not: null } },
        { lotNumber: { not: null } }
      ]
    };
    if (productId) where.productId = productId;
    if (locationId) where.locationId = locationId;
    if (status) where.status = status;

    const batches = await prisma.inventory.findMany({
      where,
      include: {
        product: {
          include: {
            brand: true
          }
        },
        location: true,
        warehouse: true
      },
      orderBy: [
        { receivedDate: 'asc' }, // FIFO ordering
        { batchNumber: 'asc' }
      ]
    });

    res.json(batches);
  } catch (error) {
    console.error('Get batches error:', error);
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// Get batch by ID
app.get('/api/inventory/batches/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;

    const batch = await prisma.inventory.findUnique({
      where: { id },
      include: {
        product: {
          include: {
            brand: true
          }
        },
        location: true,
        warehouse: true
      }
    });

    if (!batch) {
      return res.status(404).json({ error: 'Batch not found' });
    }

    res.json(batch);
  } catch (error) {
    console.error('Get batch error:', error);
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// Create new batch
app.post('/api/inventory/batches', verifyToken, async (req, res) => {
  try {
    const {
      batchNumber,
      lotNumber,
      productId,
      warehouseId,
      locationId,
      quantity,
      receivedDate,
      bestBeforeDate
    } = req.body;

    if (!productId || !warehouseId || !quantity) {
      return res.status(400).json({
        error: 'Product, warehouse, and quantity are required'
      });
    }

    if (!batchNumber && !lotNumber) {
      return res.status(400).json({
        error: 'Either batchNumber or lotNumber is required for batch tracking'
      });
    }

    // Check if batch/lot already exists for this product at this location
    const existingBatch = await prisma.inventory.findFirst({
      where: {
        productId,
        warehouseId,
        locationId: locationId || null,
        OR: [
          { batchNumber: batchNumber || null },
          { lotNumber: lotNumber || null }
        ]
      }
    });

    if (existingBatch) {
      return res.status(400).json({
        error: 'Batch/Lot number already exists for this product at this location'
      });
    }

    const batch = await prisma.inventory.create({
      data: {
        productId,
        warehouseId,
        locationId: locationId || null,
        batchNumber: batchNumber || null,
        lotNumber: lotNumber || null,
        quantity: parseInt(quantity),
        availableQuantity: parseInt(quantity),
        reservedQuantity: 0,
        receivedDate: receivedDate ? new Date(receivedDate) : new Date(),
        bestBeforeDate: bestBeforeDate ? new Date(bestBeforeDate) : null,
        status: 'AVAILABLE'
      },
      include: {
        product: {
          include: {
            brand: true
          }
        },
        warehouse: true,
        location: true
      }
    });

    res.status(201).json(batch);
  } catch (error) {
    console.error('Create batch error:', error);
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// Allocate inventory using FIFO (First In, First Out)
app.post('/api/inventory/batches/allocate-fifo', verifyToken, async (req, res) => {
  try {
    const { productId, warehouseId, locationId, quantityNeeded } = req.body;

    if (!productId || !quantityNeeded) {
      return res.status(400).json({
        error: 'Product ID and quantity needed are required'
      });
    }

    // Get batches ordered by FIFO (oldest first)
    const where = {
      productId,
      status: 'AVAILABLE',
      availableQuantity: {
        gt: 0
      },
      OR: [
        { batchNumber: { not: null } },
        { lotNumber: { not: null } }
      ]
    };
    if (warehouseId) where.warehouseId = warehouseId;
    if (locationId) where.locationId = locationId;

    const batches = await prisma.inventory.findMany({
      where,
      orderBy: [
        { receivedDate: 'asc' }, // FIFO - oldest first
        { batchNumber: 'asc' }
      ],
      include: {
        product: {
          include: {
            brand: true
          }
        },
        warehouse: true,
        location: true
      }
    });

    if (batches.length === 0) {
      return res.status(404).json({
        error: 'No available batches found for this product'
      });
    }

    // Calculate total available
    const totalAvailable = batches.reduce((sum, batch) => sum + batch.availableQuantity, 0);

    if (totalAvailable < quantityNeeded) {
      return res.status(400).json({
        error: `Insufficient inventory. Available: ${totalAvailable}, Needed: ${quantityNeeded}`
      });
    }

    // Allocate from batches using FIFO
    const allocations = [];
    let remainingNeeded = parseFloat(quantityNeeded);

    for (const batch of batches) {
      if (remainingNeeded <= 0) break;

      const allocatedQty = Math.min(batch.availableQuantity, remainingNeeded);

      allocations.push({
        batchId: batch.id,
        batchNumber: batch.batchNumber || batch.lotNumber,
        lotNumber: batch.lotNumber,
        quantity: allocatedQty,
        receivedDate: batch.receivedDate,
        bestBeforeDate: batch.bestBeforeDate,
        warehouse: batch.warehouse,
        location: batch.location
      });

      // Update batch available/reserved quantities
      await prisma.inventory.update({
        where: { id: batch.id },
        data: {
          availableQuantity: {
            decrement: allocatedQty
          },
          reservedQuantity: {
            increment: allocatedQty
          },
          status: batch.availableQuantity - allocatedQty === 0 ? 'RESERVED' : 'AVAILABLE'
        }
      });

      remainingNeeded -= allocatedQty;
    }

    res.json({
      method: 'FIFO',
      totalAllocated: parseFloat(quantityNeeded),
      allocations
    });
  } catch (error) {
    console.error('FIFO allocation error:', error);
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// Allocate inventory using LIFO (Last In, First Out)
app.post('/api/inventory/batches/allocate-lifo', verifyToken, async (req, res) => {
  try {
    const { productId, warehouseId, locationId, quantityNeeded } = req.body;

    if (!productId || !quantityNeeded) {
      return res.status(400).json({
        error: 'Product ID and quantity needed are required'
      });
    }

    // Get batches ordered by LIFO (newest first)
    const where = {
      productId,
      status: 'AVAILABLE',
      availableQuantity: {
        gt: 0
      },
      OR: [
        { batchNumber: { not: null } },
        { lotNumber: { not: null } }
      ]
    };
    if (warehouseId) where.warehouseId = warehouseId;
    if (locationId) where.locationId = locationId;

    const batches = await prisma.inventory.findMany({
      where,
      orderBy: [
        { receivedDate: 'desc' }, // LIFO - newest first
        { batchNumber: 'desc' }
      ],
      include: {
        product: {
          include: {
            brand: true
          }
        },
        warehouse: true,
        location: true
      }
    });

    if (batches.length === 0) {
      return res.status(404).json({
        error: 'No available batches found for this product'
      });
    }

    // Calculate total available
    const totalAvailable = batches.reduce((sum, batch) => sum + batch.availableQuantity, 0);

    if (totalAvailable < quantityNeeded) {
      return res.status(400).json({
        error: `Insufficient inventory. Available: ${totalAvailable}, Needed: ${quantityNeeded}`
      });
    }

    // Allocate from batches using LIFO
    const allocations = [];
    let remainingNeeded = parseFloat(quantityNeeded);

    for (const batch of batches) {
      if (remainingNeeded <= 0) break;

      const allocatedQty = Math.min(batch.availableQuantity, remainingNeeded);

      allocations.push({
        batchId: batch.id,
        batchNumber: batch.batchNumber || batch.lotNumber,
        lotNumber: batch.lotNumber,
        quantity: allocatedQty,
        receivedDate: batch.receivedDate,
        bestBeforeDate: batch.bestBeforeDate,
        warehouse: batch.warehouse,
        location: batch.location
      });

      // Update batch available/reserved quantities
      await prisma.inventory.update({
        where: { id: batch.id },
        data: {
          availableQuantity: {
            decrement: allocatedQty
          },
          reservedQuantity: {
            increment: allocatedQty
          },
          status: batch.availableQuantity - allocatedQty === 0 ? 'RESERVED' : 'AVAILABLE'
        }
      });

      remainingNeeded -= allocatedQty;
    }

    res.json({
      method: 'LIFO',
      totalAllocated: parseFloat(quantityNeeded),
      allocations
    });
  } catch (error) {
    console.error('LIFO allocation error:', error);
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// Allocate inventory using FEFO (First Expired, First Out)
app.post('/api/inventory/batches/allocate-fefo', verifyToken, async (req, res) => {
  try {
    const { productId, warehouseId, locationId, quantityNeeded } = req.body;

    if (!productId || !quantityNeeded) {
      return res.status(400).json({
        error: 'Product ID and quantity needed are required'
      });
    }

    // Get batches ordered by FEFO (earliest best-before date first)
    const where = {
      productId,
      status: 'AVAILABLE',
      availableQuantity: {
        gt: 0
      },
      bestBeforeDate: {
        not: null
      },
      OR: [
        { batchNumber: { not: null } },
        { lotNumber: { not: null } }
      ]
    };
    if (warehouseId) where.warehouseId = warehouseId;
    if (locationId) where.locationId = locationId;

    const batches = await prisma.inventory.findMany({
      where,
      orderBy: [
        { bestBeforeDate: 'asc' }, // FEFO - earliest expiry first
        { batchNumber: 'asc' }
      ],
      include: {
        product: {
          include: {
            brand: true
          }
        },
        warehouse: true,
        location: true
      }
    });

    if (batches.length === 0) {
      return res.status(404).json({
        error: 'No available batches with best-before dates found for this product'
      });
    }

    // Calculate total available
    const totalAvailable = batches.reduce((sum, batch) => sum + batch.availableQuantity, 0);

    if (totalAvailable < quantityNeeded) {
      return res.status(400).json({
        error: `Insufficient inventory. Available: ${totalAvailable}, Needed: ${quantityNeeded}`
      });
    }

    // Allocate from batches using FEFO
    const allocations = [];
    let remainingNeeded = parseFloat(quantityNeeded);

    for (const batch of batches) {
      if (remainingNeeded <= 0) break;

      const allocatedQty = Math.min(batch.availableQuantity, remainingNeeded);

      allocations.push({
        batchId: batch.id,
        batchNumber: batch.batchNumber || batch.lotNumber,
        lotNumber: batch.lotNumber,
        quantity: allocatedQty,
        receivedDate: batch.receivedDate,
        bestBeforeDate: batch.bestBeforeDate,
        warehouse: batch.warehouse,
        location: batch.location
      });

      // Update batch available/reserved quantities
      await prisma.inventory.update({
        where: { id: batch.id },
        data: {
          availableQuantity: {
            decrement: allocatedQty
          },
          reservedQuantity: {
            increment: allocatedQty
          },
          status: batch.availableQuantity - allocatedQty === 0 ? 'RESERVED' : 'AVAILABLE'
        }
      });

      remainingNeeded -= allocatedQty;
    }

    res.json({
      method: 'FEFO',
      totalAllocated: parseFloat(quantityNeeded),
      allocations
    });
  } catch (error) {
    console.error('FEFO allocation error:', error);
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// Update batch status
app.patch('/api/inventory/batches/:id/status', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;

    const validStatuses = ['AVAILABLE', 'RESERVED', 'QUARANTINE', 'DAMAGED', 'EXPIRED'];
    if (!validStatuses.includes(status)) {
      return res.status(400).json({
        error: 'Invalid status. Must be one of: ' + validStatuses.join(', ')
      });
    }

    const batch = await prisma.inventory.update({
      where: { id },
      data: { status },
      include: {
        product: {
          include: {
            brand: true
          }
        },
        warehouse: true,
        location: true
      }
    });

    res.json(batch);
  } catch (error) {
    console.error('Update batch status error:', error);
    res.status(500).json({ error: 'Internal server error', details: error.message });
  }
});

// ===================================
// INVENTORY MOVEMENTS
// ===================================

// Get all inventory movements
app.get('/api/inventory/movements', verifyToken, async (req, res) => {
  try {
    const { productId, type, startDate, endDate, limit } = req.query;

    // Check if model exists (Prisma client may need regeneration)
    if (!prisma.inventoryMovement) {
      console.log('InventoryMovement model not available - returning empty array');
      return res.json([]);
    }

    const where = {};
    if (productId) where.productId = productId;
    if (type) where.type = type;
    if (startDate || endDate) {
      where.createdAt = {};
      if (startDate) where.createdAt.gte = new Date(startDate);
      if (endDate) where.createdAt.lte = new Date(endDate);
    }

    const movements = await prisma.inventoryMovement.findMany({
      where,
      include: {
        product: {
          include: {
            brand: true
          }
        },
        fromLocation: true,
        toLocation: true,
        batch: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: limit ? parseInt(limit) : 100
    });

    res.json(movements);
  } catch (error) {
    console.error('Get movements error:', error);
    // Return empty array instead of 500 if model doesn't exist
    if (error.message?.includes('undefined')) {
      return res.json([]);
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create inventory movement
app.post('/api/inventory/movements', verifyToken, async (req, res) => {
  try {
    const {
      type,
      productId,
      batchId,
      fromLocationId,
      toLocationId,
      quantity,
      reason,
      notes
    } = req.body;

    if (!type || !productId || !quantity) {
      return res.status(400).json({
        error: 'Type, product, and quantity are required'
      });
    }

    const movement = await prisma.inventoryMovement.create({
      data: {
        id: require('crypto').randomUUID(),
        type,
        productId,
        batchId,
        fromLocationId,
        toLocationId,
        quantity: parseFloat(quantity),
        reason,
        notes,
        userId: req.user.id,
        createdAt: new Date()
      },
      include: {
        product: true,
        fromLocation: true,
        toLocation: true,
        batch: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      }
    });

    res.status(201).json(movement);
  } catch (error) {
    console.error('Create movement error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get movement history for a product
app.get('/api/inventory/movements/product/:productId', verifyToken, async (req, res) => {
  try {
    const { productId } = req.params;
    const { limit } = req.query;

    const movements = await prisma.inventoryMovement.findMany({
      where: { productId },
      include: {
        fromLocation: true,
        toLocation: true,
        batch: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: limit ? parseInt(limit) : 50
    });

    res.json(movements);
  } catch (error) {
    console.error('Get product movements error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get movement history for a batch
app.get('/api/inventory/movements/batch/:batchId', verifyToken, async (req, res) => {
  try {
    const { batchId } = req.params;

    const movements = await prisma.inventoryMovement.findMany({
      where: { batchId },
      include: {
        product: true,
        fromLocation: true,
        toLocation: true,
        user: {
          select: {
            id: true,
            name: true,
            email: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    res.json(movements);
  } catch (error) {
    console.error('Get batch movements error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// BRANDS (formerly Categories)
// ===================================

app.get('/api/brands', verifyToken, async (req, res) => {
  try {
    const brands = await prisma.brand.findMany({
      include: {
        _count: {
          select: { products: true }
        }
      },
      orderBy: { name: 'asc' }
    });

    res.json(brands);
  } catch (error) {
    console.error('Get brands error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// GET brand by ID
app.get('/api/brands/:id', verifyToken, async (req, res) => {
  try {
    const brand = await prisma.brand.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      },
      include: {
        products: { select: { id: true, name: true, sku: true } }
      }
    });
    if (!brand) {
      return res.status(404).json({ error: 'Brand not found' });
    }
    res.json(brand);
  } catch (error) {
    console.error('Get brand by ID error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/brands', verifyToken, async (req, res) => {
  try {
    const { name, code, description, companyId } = req.body;

    const brand = await prisma.brand.create({
      data: {
        name,
        code,
        description,
        companyId: companyId || req.user.companyId
      }
    });

    res.status(201).json(brand);
  } catch (error) {
    console.error('Create brand error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Legacy endpoint for backward compatibility
app.get('/api/categories', verifyToken, async (req, res) => {
  try {
    const brands = await prisma.brand.findMany({
      include: {
        _count: {
          select: { products: true }
        }
      },
      orderBy: { name: 'asc' }
    });

    res.json(brands);
  } catch (error) {
    console.error('Get categories error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// PRODUCTS (with Bundles)
// ===================================

app.get('/api/products', verifyToken, async (req, res) => {
  try {
    const { type, brandId, status } = req.query;

    const where = {};
    if (type) where.type = type.toUpperCase();
    if (brandId) where.brandId = brandId;
    if (status) where.status = status.toUpperCase();

    const products = await prisma.product.findMany({
      where,
      include: {
        brand: true,
        bundleItems: {
          include: {
            child: true
          }
        },
        _count: {
          select: { inventory: true }
        }
      },
      orderBy: { name: 'asc' }
    });

    res.json(products);
  } catch (error) {
    console.error('Get products error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/api/products/:id', verifyToken, async (req, res) => {
  try {
    const product = await prisma.product.findUnique({
      where: { id: req.params.id },
      include: {
        brand: true,
        bundleItems: {
          include: {
            child: {
              include: {
                brand: true
              }
            }
          }
        },
        partOfBundles: {
          include: {
            parent: true
          }
        },
        inventory: {
          include: {
            warehouse: true,
            location: true
          },
          orderBy: { bestBeforeDate: 'asc' }
        },
        replenConfig: true,
        channelPrices: {
          include: {
            channel: true
          }
        }
      }
    });

    if (!product) {
      return res.status(404).json({ error: 'Product not found' });
    }

    res.json(product);
  } catch (error) {
    console.error('Get product error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/products', verifyToken, async (req, res) => {
  try {
    const { bundleItems, reorderPoint, maxStockLevel, reorderQuantity, unitOfMeasure, ...rawProductData } = req.body;

    // Only include valid Product model fields
    const productData = {
      sku: rawProductData.sku,
      name: rawProductData.name,
      description: rawProductData.description || null,
      barcode: rawProductData.barcode || null,
      brandId: rawProductData.brandId || null,
      type: rawProductData.type || 'SIMPLE',
      status: rawProductData.status || 'ACTIVE',
      length: rawProductData.length || null,
      width: rawProductData.width || null,
      height: rawProductData.height || null,
      weight: rawProductData.weight || null,
      dimensionUnit: rawProductData.dimensionUnit || 'cm',
      weightUnit: rawProductData.weightUnit || 'kg',
      costPrice: rawProductData.costPrice || null,
      sellingPrice: rawProductData.sellingPrice || null,
      currency: rawProductData.currency || 'GBP',
      isPerishable: rawProductData.isPerishable || false,
      requiresBatch: rawProductData.requiresBatch || false,
      requiresSerial: rawProductData.requiresSerial || false,
      shelfLifeDays: rawProductData.shelfLifeDays || null,
      images: rawProductData.images || [],
      companyId: rawProductData.companyId || req.user.companyId,
    };

    const product = await prisma.product.create({
      data: {
        ...productData,
        bundleItems: bundleItems ? {
          create: bundleItems.map(item => ({
            childId: item.productId,
            quantity: item.quantity
          }))
        } : undefined
      },
      include: {
        brand: true,
        bundleItems: {
          include: {
            child: true
          }
        }
      }
    });

    res.status(201).json(product);
  } catch (error) {
    console.error('Create product error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.put('/api/products/:id', verifyToken, async (req, res) => {
  try {
    const { bundleItems, reorderPoint, maxStockLevel, reorderQuantity, unitOfMeasure, companyId, ...rawProductData } = req.body;

    // Only include valid Product model fields that are provided
    const productData = {};
    if (rawProductData.sku !== undefined) productData.sku = rawProductData.sku;
    if (rawProductData.name !== undefined) productData.name = rawProductData.name;
    if (rawProductData.description !== undefined) productData.description = rawProductData.description;
    if (rawProductData.barcode !== undefined) productData.barcode = rawProductData.barcode;
    if (rawProductData.brandId !== undefined) productData.brandId = rawProductData.brandId;
    if (rawProductData.type !== undefined) productData.type = rawProductData.type;
    if (rawProductData.status !== undefined) productData.status = rawProductData.status;
    if (rawProductData.length !== undefined) productData.length = rawProductData.length;
    if (rawProductData.width !== undefined) productData.width = rawProductData.width;
    if (rawProductData.height !== undefined) productData.height = rawProductData.height;
    if (rawProductData.weight !== undefined) productData.weight = rawProductData.weight;
    if (rawProductData.dimensionUnit !== undefined) productData.dimensionUnit = rawProductData.dimensionUnit;
    if (rawProductData.weightUnit !== undefined) productData.weightUnit = rawProductData.weightUnit;
    if (rawProductData.costPrice !== undefined) productData.costPrice = rawProductData.costPrice;
    if (rawProductData.sellingPrice !== undefined) productData.sellingPrice = rawProductData.sellingPrice;
    if (rawProductData.currency !== undefined) productData.currency = rawProductData.currency;
    if (rawProductData.isPerishable !== undefined) productData.isPerishable = rawProductData.isPerishable;
    if (rawProductData.requiresBatch !== undefined) productData.requiresBatch = rawProductData.requiresBatch;
    if (rawProductData.requiresSerial !== undefined) productData.requiresSerial = rawProductData.requiresSerial;
    if (rawProductData.shelfLifeDays !== undefined) productData.shelfLifeDays = rawProductData.shelfLifeDays;
    if (rawProductData.images !== undefined) productData.images = rawProductData.images;

    // If updating bundle items, delete old ones first
    if (bundleItems !== undefined) {
      await prisma.bundleItem.deleteMany({
        where: { parentId: req.params.id }
      });
    }

    const product = await prisma.product.update({
      where: { id: req.params.id },
      data: {
        ...productData,
        bundleItems: bundleItems ? {
          create: bundleItems.map(item => ({
            childId: item.productId,
            quantity: item.quantity
          }))
        } : undefined
      },
      include: {
        brand: true,
        bundleItems: {
          include: {
            child: true
          }
        }
      }
    });

    res.json(product);
  } catch (error) {
    console.error('Update product error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Delete product
app.delete('/api/products/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;

    // First delete related bundle items
    await prisma.bundleItem.deleteMany({
      where: {
        OR: [
          { parentId: id },
          { childId: id }
        ]
      }
    });

    // Delete the product
    await prisma.product.delete({
      where: { id }
    });

    res.json({ message: 'Product deleted successfully' });
  } catch (error) {
    console.error('Delete product error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// BRANDS - UPDATE and DELETE
// ===================================

// Update brand
app.put('/api/brands/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, code, description } = req.body;

    const brand = await prisma.brand.update({
      where: { id },
      data: {
        name,
        code,
        description,
        updatedAt: new Date()
      }
    });

    res.json(brand);
  } catch (error) {
    console.error('Update brand error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Delete brand
app.delete('/api/brands/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;

    // Check if any products use this brand
    const productsUsingBrand = await prisma.product.count({
      where: { brandId: id }
    });

    if (productsUsingBrand > 0) {
      return res.status(400).json({
        error: `Cannot delete brand: ${productsUsingBrand} products are using this brand`
      });
    }

    await prisma.brand.delete({
      where: { id }
    });

    res.json({ message: 'Brand deleted successfully' });
  } catch (error) {
    console.error('Delete brand error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// INVENTORY (with BB Dates)
// ===================================

app.get('/api/inventory', verifyToken, async (req, res) => {
  try {
    const { warehouseId, productId, status } = req.query;

    const where = {};
    if (warehouseId) where.warehouseId = warehouseId;
    if (productId) where.productId = productId;
    if (status) where.status = status.toUpperCase();

    const inventory = await prisma.inventory.findMany({
      where,
      include: {
        product: {
          include: {
            brand: true
          }
        },
        warehouse: true,
        location: true
      },
      orderBy: [
        { product: { name: 'asc' } },
        { bestBeforeDate: 'asc' }
      ]
    });

    res.json(inventory);
  } catch (error) {
    console.error('Get inventory error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create inventory record
app.post('/api/inventory', verifyToken, async (req, res) => {
  try {
    const {
      productId,
      warehouseId,
      locationId,
      lotNumber,
      batchNumber,
      serialNumber,
      bestBeforeDate,
      quantity,
      availableQuantity,
      reservedQuantity,
      status
    } = req.body;

    // Validate required fields
    if (!productId || !warehouseId) {
      return res.status(400).json({ error: 'productId and warehouseId are required' });
    }

    const inventory = await prisma.inventory.create({
      data: {
        productId,
        warehouseId,
        locationId: locationId || null,
        lotNumber: lotNumber || null,
        batchNumber: batchNumber || null,
        serialNumber: serialNumber || null,
        bestBeforeDate: bestBeforeDate ? new Date(bestBeforeDate) : null,
        quantity: parseInt(quantity) || 0,
        availableQuantity: availableQuantity !== undefined ? parseInt(availableQuantity) : (parseInt(quantity) || 0),
        reservedQuantity: parseInt(reservedQuantity) || 0,
        status: status || 'AVAILABLE'
      },
      include: {
        product: {
          include: {
            brand: true
          }
        },
        warehouse: true,
        location: true
      }
    });

    res.status(201).json(inventory);
  } catch (error) {
    console.error('Create inventory error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Inventory record already exists for this product/warehouse/location/lot combination' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update inventory record
app.put('/api/inventory/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const {
      productId,
      warehouseId,
      locationId,
      lotNumber,
      batchNumber,
      serialNumber,
      bestBeforeDate,
      quantity,
      availableQuantity,
      reservedQuantity,
      status
    } = req.body;

    const inventory = await prisma.inventory.update({
      where: { id },
      data: {
        productId,
        warehouseId,
        locationId: locationId || null,
        lotNumber: lotNumber || null,
        batchNumber: batchNumber || null,
        serialNumber: serialNumber || null,
        bestBeforeDate: bestBeforeDate ? new Date(bestBeforeDate) : null,
        quantity: parseInt(quantity) || 0,
        availableQuantity: availableQuantity !== undefined ? parseInt(availableQuantity) : (parseInt(quantity) || 0),
        reservedQuantity: parseInt(reservedQuantity) || 0,
        status: status || 'AVAILABLE'
      },
      include: {
        product: {
          include: {
            brand: true
          }
        },
        warehouse: true,
        location: true
      }
    });

    res.json(inventory);
  } catch (error) {
    console.error('Update inventory error:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Inventory record not found' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Delete inventory record
app.delete('/api/inventory/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;

    await prisma.inventory.delete({
      where: { id }
    });

    res.json({ message: 'Inventory record deleted successfully' });
  } catch (error) {
    console.error('Delete inventory error:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Inventory record not found' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// SALES ORDERS (with Wholesale Flag)
// ===================================

app.get('/api/sales-orders', verifyToken, async (req, res) => {
  try {
    const { status, isWholesale, salesChannel } = req.query;

    const where = {};
    if (status) where.status = status.toUpperCase();
    if (isWholesale !== undefined) where.isWholesale = isWholesale === 'true';
    if (salesChannel) where.salesChannel = salesChannel;

    const orders = await prisma.salesOrder.findMany({
      where,
      include: {
        customer: true,
        items: {
          include: {
            product: {
              include: {
                brand: true
              }
            }
          }
        },
        pickLists: {
          include: {
            assignedUser: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    res.json(orders);
  } catch (error) {
    console.error('Get sales orders error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/sales-orders', verifyToken, async (req, res) => {
  try {
    const { items, ...orderData } = req.body;

    const order = await prisma.salesOrder.create({
      data: {
        ...orderData,
        items: {
          create: items
        }
      },
      include: {
        customer: true,
        items: {
          include: {
            product: true
          }
        }
      }
    });

    res.status(201).json(order);
  } catch (error) {
    console.error('Create sales order error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.patch('/api/sales-orders/:id/wholesale', verifyToken, async (req, res) => {
  try {
    const { isWholesale } = req.body;

    const order = await prisma.salesOrder.update({
      where: { id: req.params.id },
      data: { isWholesale },
      include: {
        customer: true,
        items: {
          include: {
            product: true
          }
        }
      }
    });

    res.json(order);
  } catch (error) {
    console.error('Update wholesale flag error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// WAREHOUSES
// ===================================

app.get('/api/warehouses', verifyToken, async (req, res) => {
  try {
    const warehouses = await prisma.warehouse.findMany({
      include: {
        zones: true,
        _count: {
          select: { inventory: true }
        }
      },
      orderBy: { name: 'asc' }
    });

    res.json(warehouses);
  } catch (error) {
    console.error('Get warehouses error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// LOCATIONS (Warehouse storage locations)
// ===================================

// Get all locations
app.get('/api/locations', verifyToken, async (req, res) => {
  try {
    const { warehouseId, zoneId } = req.query;

    const where = {};
    if (warehouseId) where.warehouseId = warehouseId;
    if (zoneId) where.zoneId = zoneId;

    const locations = await prisma.location.findMany({
      where,
      include: {
        warehouse: {
          select: { id: true, name: true, code: true }
        },
        zone: {
          select: { id: true, name: true, code: true }
        },
        _count: {
          select: { inventory: true }
        }
      },
      orderBy: [
        { warehouse: { name: 'asc' } },
        { code: 'asc' }
      ]
    });

    res.json(locations);
  } catch (error) {
    console.error('Get locations error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get single location
app.get('/api/locations/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;

    const location = await prisma.location.findUnique({
      where: { id },
      include: {
        warehouse: true,
        zone: true,
        inventory: {
          include: {
            product: true
          }
        }
      }
    });

    if (!location) {
      return res.status(404).json({ error: 'Location not found' });
    }

    res.json(location);
  } catch (error) {
    console.error('Get location error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create location
app.post('/api/locations', verifyToken, async (req, res) => {
  try {
    const { name, code, warehouseId, zoneId, aisle, rack, shelf, bin } = req.body;

    if (!name || !code || !warehouseId) {
      return res.status(400).json({ error: 'Name, code, and warehouseId are required' });
    }

    // Check if warehouse exists
    const warehouse = await prisma.warehouse.findUnique({
      where: { id: warehouseId }
    });

    if (!warehouse) {
      return res.status(404).json({ error: 'Warehouse not found' });
    }

    // Check for duplicate code in same warehouse
    const existing = await prisma.location.findFirst({
      where: { warehouseId, code }
    });

    if (existing) {
      return res.status(400).json({ error: 'Location code already exists in this warehouse' });
    }

    const location = await prisma.location.create({
      data: {
        name,
        code,
        warehouseId,
        zoneId: zoneId || null,
        aisle: aisle || null,
        rack: rack || null,
        shelf: shelf || null,
        bin: bin || null
      },
      include: {
        warehouse: true,
        zone: true
      }
    });

    res.status(201).json(location);
  } catch (error) {
    console.error('Create location error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update location
app.put('/api/locations/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, code, warehouseId, zoneId, aisle, rack, shelf, bin } = req.body;

    const existing = await prisma.location.findUnique({
      where: { id }
    });

    if (!existing) {
      return res.status(404).json({ error: 'Location not found' });
    }

    // Check for duplicate code if changing
    if (code && code !== existing.code) {
      const duplicate = await prisma.location.findFirst({
        where: {
          warehouseId: warehouseId || existing.warehouseId,
          code,
          NOT: { id }
        }
      });

      if (duplicate) {
        return res.status(400).json({ error: 'Location code already exists in this warehouse' });
      }
    }

    const location = await prisma.location.update({
      where: { id },
      data: {
        name: name !== undefined ? name : existing.name,
        code: code !== undefined ? code : existing.code,
        warehouseId: warehouseId !== undefined ? warehouseId : existing.warehouseId,
        zoneId: zoneId !== undefined ? (zoneId || null) : existing.zoneId,
        aisle: aisle !== undefined ? (aisle || null) : existing.aisle,
        rack: rack !== undefined ? (rack || null) : existing.rack,
        shelf: shelf !== undefined ? (shelf || null) : existing.shelf,
        bin: bin !== undefined ? (bin || null) : existing.bin
      },
      include: {
        warehouse: true,
        zone: true
      }
    });

    res.json(location);
  } catch (error) {
    console.error('Update location error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Delete location
app.delete('/api/locations/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;

    const existing = await prisma.location.findUnique({
      where: { id },
      include: {
        _count: {
          select: { inventory: true }
        }
      }
    });

    if (!existing) {
      return res.status(404).json({ error: 'Location not found' });
    }

    // Check if location has inventory
    if (existing._count.inventory > 0) {
      return res.status(400).json({
        error: 'Cannot delete location with existing inventory',
        inventoryCount: existing._count.inventory
      });
    }

    await prisma.location.delete({
      where: { id }
    });

    res.json({ message: 'Location deleted successfully' });
  } catch (error) {
    console.error('Delete location error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// CUSTOMERS
// ===================================

app.get('/api/customers', verifyToken, async (req, res) => {
  try {
    const customers = await prisma.customer.findMany({
      include: {
        _count: {
          select: { orders: true }
        }
      },
      orderBy: { name: 'asc' }
    });

    res.json(customers);
  } catch (error) {
    console.error('Get customers error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// REPLENISHMENT
// ===================================

app.get('/api/replenishment/tasks', verifyToken, async (req, res) => {
  try {
    const { status } = req.query;

    const where = {};
    if (status) where.status = status.toUpperCase();

    const tasks = await prisma.replenishmentTask.findMany({
      where,
      include: {
        product: {
          include: {
            brand: true
          }
        }
      },
      orderBy: [
        { priority: 'desc' },
        { createdAt: 'asc' }
      ]
    });

    res.json(tasks);
  } catch (error) {
    console.error('Get replenishment tasks error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/api/replenishment/config', verifyToken, async (req, res) => {
  try {
    const configs = await prisma.replenishmentConfig.findMany({
      include: {
        product: {
          include: {
            brand: true
          }
        }
      },
      orderBy: { product: { name: 'asc' } }
    });

    res.json(configs);
  } catch (error) {
    console.error('Get replenishment configs error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/replenishment/config', verifyToken, async (req, res) => {
  try {
    const config = await prisma.replenishmentConfig.create({
      data: req.body,
      include: {
        product: true
      }
    });

    res.status(201).json(config);
  } catch (error) {
    console.error('Create replenishment config error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// FBA TRANSFERS
// ===================================

app.get('/api/transfers', verifyToken, async (req, res) => {
  try {
    const { type, status } = req.query;

    const where = {};
    if (type) where.type = type.toUpperCase();
    if (status) where.status = status.toUpperCase();

    const transfers = await prisma.transfer.findMany({
      where,
      include: {
        fromWarehouse: true,
        toWarehouse: true,
        items: true
      },
      orderBy: { createdAt: 'desc' }
    });

    res.json(transfers);
  } catch (error) {
    console.error('Get transfers error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/transfers', verifyToken, async (req, res) => {
  try {
    const { items, ...transferData } = req.body;

    const transfer = await prisma.transfer.create({
      data: {
        ...transferData,
        items: {
          create: items
        }
      },
      include: {
        fromWarehouse: true,
        toWarehouse: true,
        items: true
      }
    });

    res.status(201).json(transfer);
  } catch (error) {
    console.error('Create transfer error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// SALES CHANNELS & ANALYTICS
// ===================================

app.get('/api/channels', verifyToken, async (req, res) => {
  try {
    const channels = await prisma.salesChannel.findMany({
      where: { isActive: true },
      include: {
        _count: {
          select: { channelPrices: true }
        }
      },
      orderBy: { name: 'asc' }
    });

    res.json(channels);
  } catch (error) {
    console.error('Get channels error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/api/analytics/channel-prices', verifyToken, async (req, res) => {
  try {
    const { channelId, productId } = req.query;

    const where = { isActive: true };
    if (channelId) where.channelId = channelId;
    if (productId) where.productId = productId;

    const prices = await prisma.channelPrice.findMany({
      where,
      include: {
        product: {
          include: {
            brand: true
          }
        },
        channel: true
      },
      orderBy: [
        { product: { name: 'asc' } },
        { channel: { name: 'asc' } }
      ]
    });

    res.json(prices);
  } catch (error) {
    console.error('Get channel prices error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/analytics/channel-prices', verifyToken, async (req, res) => {
  try {
    const price = await prisma.channelPrice.create({
      data: req.body,
      include: {
        product: true,
        channel: true
      }
    });

    res.status(201).json(price);
  } catch (error) {
    console.error('Create channel price error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// COMPANIES
// ===================================

app.get('/api/companies', verifyToken, async (req, res) => {
  try {
    const companies = await prisma.company.findMany({
      include: {
        _count: {
          select: {
            warehouses: true,
            products: true,
            users: true
          }
        }
      },
      orderBy: { name: 'asc' }
    });

    res.json(companies);
  } catch (error) {
    console.error('Get companies error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get single company by ID
app.get('/api/companies/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const company = await prisma.company.findUnique({
      where: { id },
      include: {
        warehouses: true,
        users: { select: { id: true, name: true, email: true, role: true } },
        _count: {
          select: {
            warehouses: true,
            products: true,
            users: true,
            customers: true,
            suppliers: true
          }
        }
      }
    });

    if (!company) {
      return res.status(404).json({ error: 'Company not found' });
    }

    res.json(company);
  } catch (error) {
    console.error('Get company error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create new company
app.post('/api/companies', verifyToken, async (req, res) => {
  try {
    const { name, code, description, address, phone, email } = req.body;

    if (!name || !code) {
      return res.status(400).json({ error: 'Name and code are required' });
    }

    // Check if code already exists
    const existing = await prisma.company.findUnique({ where: { code } });
    if (existing) {
      return res.status(400).json({ error: 'Company code already exists' });
    }

    const company = await prisma.company.create({
      data: {
        name,
        code: code.toUpperCase(),
        description,
        address,
        phone,
        email
      }
    });

    res.status(201).json(company);
  } catch (error) {
    console.error('Create company error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update company
app.put('/api/companies/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, code, description, address, phone, email } = req.body;

    const company = await prisma.company.update({
      where: { id },
      data: {
        name,
        code: code?.toUpperCase(),
        description,
        address,
        phone,
        email
      }
    });

    res.json(company);
  } catch (error) {
    console.error('Update company error:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Company not found' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Delete company
app.delete('/api/companies/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;

    await prisma.company.delete({ where: { id } });

    res.json({ message: 'Company deleted successfully' });
  } catch (error) {
    console.error('Delete company error:', error);
    if (error.code === 'P2025') {
      return res.status(404).json({ error: 'Company not found' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// SPRINT 4: BARCODE & DOCUMENT MANAGEMENT
// ===================================

// 1. Generate barcode for product
app.post('/api/barcode/generate', verifyToken, async (req, res) => {
  try {
    const { productId, format = 'CODE128', width = 2, height = 100 } = req.body;

    if (!productId) {
      return res.status(400).json({ error: 'Product ID is required' });
    }

    const product = await prisma.product.findUnique({
      where: { id: productId },
      include: { brand: true }
    });

    if (!product) {
      return res.status(404).json({ error: 'Product not found' });
    }

    // Generate barcode value (use SKU or generate)
    const barcodeValue = product.sku || `WMS${product.id.substring(0, 8)}`;

    res.json({
      productId: product.id,
      productName: product.name,
      sku: product.sku,
      barcode: barcodeValue,
      format,
      width,
      height,
      createdAt: new Date()
    });
  } catch (error) {
    console.error('Generate barcode error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// 2. Batch generate barcodes
app.post('/api/barcode/generate/batch', verifyToken, async (req, res) => {
  try {
    const { productIds, format = 'CODE128' } = req.body;

    if (!productIds || !Array.isArray(productIds)) {
      return res.status(400).json({ error: 'Product IDs array is required' });
    }

    const products = await prisma.product.findMany({
      where: { id: { in: productIds } },
      include: { brand: true }
    });

    const barcodes = products.map(product => ({
      productId: product.id,
      productName: product.name,
      sku: product.sku,
      barcode: product.sku || `WMS${product.id.substring(0, 8)}`,
      format,
      brand: product.brand?.name || 'N/A'
    }));

    res.json({
      total: barcodes.length,
      barcodes,
      generatedAt: new Date()
    });
  } catch (error) {
    console.error('Batch generate barcodes error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// 3. Generate QR code for location
app.post('/api/qrcode/generate', verifyToken, async (req, res) => {
  try {
    const { locationId, type = 'location' } = req.body;

    if (!locationId) {
      return res.status(400).json({ error: 'Location ID is required' });
    }

    const location = await prisma.location.findUnique({
      where: { id: locationId },
      include: { warehouse: true }
    });

    if (!location) {
      return res.status(404).json({ error: 'Location not found' });
    }

    // Generate QR code data
    const qrData = JSON.stringify({
      type: 'location',
      id: location.id,
      code: `${location.aisle}-${location.rack}-${location.bin}`,
      warehouse: location.warehouse?.name || 'N/A',
      timestamp: new Date().toISOString()
    });

    res.json({
      locationId: location.id,
      locationCode: `${location.aisle}-${location.rack}-${location.bin}`,
      warehouse: location.warehouse?.name || 'N/A',
      qrData,
      type,
      createdAt: new Date()
    });
  } catch (error) {
    console.error('Generate QR code error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// 4. Lookup product by barcode
app.get('/api/barcode/lookup/:barcode', verifyToken, async (req, res) => {
  try {
    const { barcode } = req.params;

    const product = await prisma.product.findFirst({
      where: { sku: barcode },
      include: {
        brand: true,
        inventory: {
          include: {
            location: {
              include: { warehouse: true }
            }
          }
        }
      }
    });

    if (!product) {
      return res.status(404).json({ error: 'Product not found with this barcode' });
    }

    // Calculate total available quantity
    const totalAvailable = product.inventory.reduce((sum, inv) => sum + (inv.availableQuantity || 0), 0);

    res.json({
      id: product.id,
      name: product.name,
      sku: product.sku,
      barcode: product.sku,
      brand: product.brand?.name || 'N/A',
      price: product.price,
      totalAvailable,
      locations: product.inventory.map(inv => ({
        id: inv.id,
        locationCode: `${inv.location?.aisle}-${inv.location?.rack}-${inv.location?.bin}`,
        warehouse: inv.location?.warehouse?.name || 'N/A',
        quantity: inv.availableQuantity,
        expiryDate: inv.bestBeforeDate
      }))
    });
  } catch (error) {
    console.error('Barcode lookup error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// 5. Generate pick list document data
app.get('/api/documents/pick-list/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;

    const pickList = await prisma.pickList.findUnique({
      where: { id },
      include: {
        items: {
          include: {
            product: {
              include: { brand: true }
            },
            location: {
              include: { warehouse: true }
            }
          }
        },
        assignedTo: true,
        createdBy: true
      }
    });

    if (!pickList) {
      return res.status(404).json({ error: 'Pick list not found' });
    }

    // Group items by zone/aisle for efficient picking
    const groupedItems = pickList.items.reduce((acc, item) => {
      const zone = item.location?.aisle || 'Unknown';
      if (!acc[zone]) acc[zone] = [];
      acc[zone].push({
        productName: item.product?.name || 'Unknown',
        sku: item.product?.sku || 'N/A',
        brand: item.product?.brand?.name || 'N/A',
        quantity: item.quantity,
        location: `${item.location?.aisle}-${item.location?.rack}-${item.location?.bin}`,
        barcode: item.product?.sku || ''
      });
      return acc;
    }, {});

    res.json({
      pickListNumber: pickList.id.substring(0, 8).toUpperCase(),
      status: pickList.status,
      priority: pickList.priority || 'MEDIUM',
      createdAt: pickList.createdAt,
      assignedTo: pickList.assignedTo?.name || 'Unassigned',
      createdBy: pickList.createdBy?.name || 'System',
      totalItems: pickList.items.length,
      groupedItems,
      notes: pickList.notes || ''
    });
  } catch (error) {
    console.error('Generate pick list document error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// 6. Generate packing slip document data
app.post('/api/documents/packing-slip', verifyToken, async (req, res) => {
  try {
    const { orderId, items, shippingInfo } = req.body;

    if (!items || !Array.isArray(items)) {
      return res.status(400).json({ error: 'Items array is required' });
    }

    // Get product details for items
    const productIds = items.map(item => item.productId);
    const products = await prisma.product.findMany({
      where: { id: { in: productIds } },
      include: { brand: true }
    });

    const itemsWithDetails = items.map(item => {
      const product = products.find(p => p.id === item.productId);
      return {
        productName: product?.name || 'Unknown',
        sku: product?.sku || 'N/A',
        brand: product?.brand?.name || 'N/A',
        quantity: item.quantity,
        price: product?.price || 0
      };
    });

    const subtotal = itemsWithDetails.reduce((sum, item) => sum + (item.price * item.quantity), 0);

    res.json({
      packingSlipNumber: `PS-${Date.now()}`,
      orderId: orderId || 'N/A',
      date: new Date(),
      items: itemsWithDetails,
      totalItems: items.length,
      totalQuantity: items.reduce((sum, item) => sum + item.quantity, 0),
      subtotal,
      shippingInfo: shippingInfo || {
        name: '',
        address: '',
        city: '',
        state: '',
        zip: '',
        country: ''
      }
    });
  } catch (error) {
    console.error('Generate packing slip error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// 7. Generate shipping label document data
app.post('/api/documents/shipping-label', verifyToken, async (req, res) => {
  try {
    const { orderId, shipTo, shipFrom, weight, dimensions } = req.body;

    if (!shipTo || !shipTo.name) {
      return res.status(400).json({ error: 'Shipping recipient information is required' });
    }

    res.json({
      labelNumber: `LABEL-${Date.now()}`,
      orderId: orderId || 'N/A',
      trackingNumber: `WMS${Date.now().toString().substring(5)}`,
      date: new Date(),
      shipTo,
      shipFrom: shipFrom || {
        name: 'Kiaan WMS Warehouse',
        address: '123 Warehouse St',
        city: 'Commerce',
        state: 'CA',
        zip: '90040',
        country: 'USA'
      },
      weight: weight || { value: 0, unit: 'lbs' },
      dimensions: dimensions || { length: 0, width: 0, height: 0, unit: 'in' },
      service: 'Standard Shipping',
      barcode: `WMS${Date.now()}`
    });
  } catch (error) {
    console.error('Generate shipping label error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// 8. Generate transfer document data
app.get('/api/documents/transfer/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;

    const transfer = await prisma.transfer.findUnique({
      where: { id },
      include: {
        items: {
          include: {
            product: {
              include: { brand: true }
            }
          }
        },
        fromWarehouse: true,
        toWarehouse: true,
        createdBy: true
      }
    });

    if (!transfer) {
      return res.status(404).json({ error: 'Transfer not found' });
    }

    res.json({
      transferNumber: transfer.id.substring(0, 8).toUpperCase(),
      status: transfer.status,
      transferDate: transfer.transferDate,
      fromWarehouse: transfer.fromWarehouse?.name || 'Unknown',
      toWarehouse: transfer.toWarehouse?.name || 'Unknown',
      createdBy: transfer.createdBy?.name || 'System',
      items: transfer.items.map(item => ({
        productName: item.product?.name || 'Unknown',
        sku: item.product?.sku || 'N/A',
        brand: item.product?.brand?.name || 'N/A',
        quantity: item.quantity,
        barcode: item.product?.sku || ''
      })),
      totalItems: transfer.items.length,
      totalQuantity: transfer.items.reduce((sum, item) => sum + item.quantity, 0),
      notes: transfer.notes || ''
    });
  } catch (error) {
    console.error('Generate transfer document error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// 9. Generate product label data (for printing)
app.post('/api/documents/product-label', verifyToken, async (req, res) => {
  try {
    const { productId, quantity = 1 } = req.body;

    if (!productId) {
      return res.status(400).json({ error: 'Product ID is required' });
    }

    const product = await prisma.product.findUnique({
      where: { id: productId },
      include: {
        brand: true,
        inventory: {
          include: {
            location: true
          },
          take: 1
        }
      }
    });

    if (!product) {
      return res.status(404).json({ error: 'Product not found' });
    }

    const labels = Array(quantity).fill(null).map((_, index) => ({
      labelNumber: index + 1,
      productName: product.name,
      sku: product.sku,
      brand: product.brand?.name || 'N/A',
      barcode: product.sku || `WMS${product.id.substring(0, 8)}`,
      price: product.price,
      location: product.inventory[0]
        ? `${product.inventory[0].location?.aisle}-${product.inventory[0].location?.rack}-${product.inventory[0].location?.bin}`
        : 'N/A',
      generatedAt: new Date()
    }));

    res.json({
      productId: product.id,
      quantity,
      labels
    });
  } catch (error) {
    console.error('Generate product label error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// 10. Get all document templates
app.get('/api/documents/templates', verifyToken, async (req, res) => {
  try {
    const templates = [
      {
        id: 'pick-list',
        name: 'Pick List',
        description: 'Printable pick list grouped by zone',
        category: 'Operations',
        icon: 'FileText',
        requiresId: true
      },
      {
        id: 'packing-slip',
        name: 'Packing Slip',
        description: 'Packing slip with order details',
        category: 'Shipping',
        icon: 'Package',
        requiresId: false
      },
      {
        id: 'shipping-label',
        name: 'Shipping Label',
        description: 'Shipping label with barcode',
        category: 'Shipping',
        icon: 'Tag',
        requiresId: false
      },
      {
        id: 'transfer-document',
        name: 'Transfer Document',
        description: 'Transfer order form',
        category: 'Operations',
        icon: 'Truck',
        requiresId: true
      },
      {
        id: 'product-label',
        name: 'Product Label',
        description: 'Product label with barcode',
        category: 'Inventory',
        icon: 'Barcode',
        requiresId: false
      },
      {
        id: 'location-qr',
        name: 'Location QR Code',
        description: 'QR code for warehouse location',
        category: 'Inventory',
        icon: 'QrCode',
        requiresId: false
      }
    ];

    res.json(templates);
  } catch (error) {
    console.error('Get templates error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// 11. Get barcode statistics
app.get('/api/barcode/statistics', verifyToken, async (req, res) => {
  try {
    const totalProducts = await prisma.product.count();

    // Count products with non-empty barcode
    const productsWithBarcode = await prisma.product.count({
      where: {
        barcode: {
          not: ''
        }
      }
    });

    const totalLocations = await prisma.location.count();

    res.json({
      totalProducts,
      productsWithBarcode: productsWithBarcode,
      productsWithoutBarcode: totalProducts - productsWithBarcode,
      totalLocations,
      barcodeFormat: 'CODE128',
      qrCodeFormat: 'QR_CODE'
    });
  } catch (error) {
    console.error('Get barcode statistics error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// RETURNS & RMA
// ===================================

app.get('/api/returns', verifyToken, async (req, res) => {
  try {
    // Return mock data since we don't have a Returns table yet
    const returns = [
      { id: '1', rmaNumber: 'RMA-001', orderNumber: 'ORD-1001', customer: 'John Smith', type: 'Return', reason: 'Damaged', requestedDate: new Date().toISOString(), value: 150, status: 'pending' },
      { id: '2', rmaNumber: 'RMA-002', orderNumber: 'ORD-1002', customer: 'Jane Doe', type: 'Exchange', reason: 'Wrong Item', requestedDate: new Date().toISOString(), value: 89.99, status: 'processing' },
      { id: '3', rmaNumber: 'RMA-003', orderNumber: 'ORD-1003', customer: 'Bob Wilson', type: 'Refund', reason: 'Defective', requestedDate: new Date().toISOString(), value: 299, status: 'approved' },
      { id: '4', rmaNumber: 'RMA-004', orderNumber: 'ORD-1004', customer: 'Alice Brown', type: 'Return', reason: 'Changed Mind', requestedDate: new Date().toISOString(), value: 45, status: 'completed' }
    ];
    res.json(returns);
  } catch (error) {
    console.error('Get returns error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/returns', verifyToken, async (req, res) => {
  try {
    const { orderNumber, customer, type, reason, value } = req.body;
    const newReturn = {
      id: require('crypto').randomUUID(),
      rmaNumber: `RMA-${Date.now().toString().slice(-6)}`,
      orderNumber,
      customer,
      type,
      reason,
      value: parseFloat(value),
      requestedDate: new Date().toISOString(),
      status: 'pending'
    };
    res.status(201).json(newReturn);
  } catch (error) {
    console.error('Create return error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// SHIPMENTS
// ===================================

app.get('/api/shipments', verifyToken, async (req, res) => {
  try {
    const shipments = [
      { id: '1', shipmentNumber: 'SHP-001', carrier: 'FedEx', tracking: '789456123012', status: 'in_transit', orders: 3, shipDate: new Date().toISOString(), destination: 'New York, NY' },
      { id: '2', shipmentNumber: 'SHP-002', carrier: 'UPS', tracking: '1Z999AA10123456784', status: 'pending', orders: 2, shipDate: null, destination: 'Los Angeles, CA' },
      { id: '3', shipmentNumber: 'SHP-003', carrier: 'DHL', tracking: '1234567890', status: 'delivered', orders: 5, shipDate: new Date(Date.now() - 86400000).toISOString(), destination: 'Chicago, IL' },
      { id: '4', shipmentNumber: 'SHP-004', carrier: 'USPS', tracking: '9400111899223344556677', status: 'in_transit', orders: 1, shipDate: new Date().toISOString(), destination: 'Houston, TX' }
    ];
    res.json(shipments);
  } catch (error) {
    console.error('Get shipments error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/shipments', verifyToken, async (req, res) => {
  try {
    const { carrier, tracking, destination } = req.body;
    const newShipment = {
      id: require('crypto').randomUUID(),
      shipmentNumber: `SHP-${Date.now().toString().slice(-6)}`,
      carrier,
      tracking,
      destination,
      orders: 0,
      shipDate: null,
      status: 'pending'
    };
    res.status(201).json(newShipment);
  } catch (error) {
    console.error('Create shipment error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// PACKING
// ===================================

app.get('/api/packing', verifyToken, async (req, res) => {
  try {
    const packingTasks = [
      { id: '1', packingSlip: 'PS-001', orderNumber: 'ORD-1001', packer: 'Mike Johnson', status: 'ready_to_pack', priority: 'high', items: 5, weight: '2.5 kg' },
      { id: '2', packingSlip: 'PS-002', orderNumber: 'ORD-1002', packer: 'Sarah Lee', status: 'packing', priority: 'medium', items: 3, weight: '1.2 kg' },
      { id: '3', packingSlip: 'PS-003', orderNumber: 'ORD-1003', packer: 'Tom Davis', status: 'packed', priority: 'low', items: 8, weight: '4.8 kg' },
      { id: '4', packingSlip: 'PS-004', orderNumber: 'ORD-1004', packer: 'Mike Johnson', status: 'ready_to_ship', priority: 'high', items: 2, weight: '0.8 kg' }
    ];
    res.json(packingTasks);
  } catch (error) {
    console.error('Get packing tasks error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/packing', verifyToken, async (req, res) => {
  try {
    const { orderNumber, packer, weight } = req.body;
    const newPacking = {
      id: require('crypto').randomUUID(),
      packingSlip: `PS-${Date.now().toString().slice(-6)}`,
      orderNumber,
      packer,
      weight: weight + ' kg',
      items: 0,
      priority: 'medium',
      status: 'ready_to_pack'
    };
    res.status(201).json(newPacking);
  } catch (error) {
    console.error('Create packing task error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// PICKING
// ===================================

app.get('/api/picking', verifyToken, async (req, res) => {
  try {
    const pickingTasks = [
      { id: '1', pickListNumber: 'PL-001', orderNumber: 'ORD-1001', picker: 'John Picker', status: 'pending', priority: 'high', items: 5, location: 'A-01-01' },
      { id: '2', pickListNumber: 'PL-002', orderNumber: 'ORD-1002', picker: 'Jane Picker', status: 'in_progress', priority: 'medium', items: 3, location: 'B-02-03' },
      { id: '3', pickListNumber: 'PL-003', orderNumber: 'ORD-1003', picker: 'Bob Picker', status: 'completed', priority: 'low', items: 8, location: 'C-01-02' },
      { id: '4', pickListNumber: 'PL-004', orderNumber: 'ORD-1004', picker: 'John Picker', status: 'pending', priority: 'high', items: 2, location: 'A-03-01' }
    ];
    res.json(pickingTasks);
  } catch (error) {
    console.error('Get picking tasks error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/picking', verifyToken, async (req, res) => {
  try {
    const { orderNumber, picker, priority } = req.body;
    const newPicking = {
      id: require('crypto').randomUUID(),
      pickListNumber: `PL-${Date.now().toString().slice(-6)}`,
      orderNumber,
      picker,
      priority: priority || 'medium',
      items: 0,
      location: 'TBD',
      status: 'pending'
    };
    res.status(201).json(newPicking);
  } catch (error) {
    console.error('Create picking task error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// PURCHASE ORDERS
// ===================================

app.get('/api/purchase-orders', verifyToken, async (req, res) => {
  try {
    const purchaseOrders = [
      { id: '1', poNumber: 'PO-001', supplier: 'Acme Supplies', status: 'pending', items: 10, total: 5000, createdAt: new Date().toISOString(), expectedDate: new Date(Date.now() + 604800000).toISOString() },
      { id: '2', poNumber: 'PO-002', supplier: 'Global Parts Inc', status: 'approved', items: 25, total: 12500, createdAt: new Date().toISOString(), expectedDate: new Date(Date.now() + 432000000).toISOString() },
      { id: '3', poNumber: 'PO-003', supplier: 'FastShip Co', status: 'received', items: 15, total: 3200, createdAt: new Date(Date.now() - 604800000).toISOString(), expectedDate: new Date().toISOString() },
      { id: '4', poNumber: 'PO-004', supplier: 'Quality Goods Ltd', status: 'partial', items: 50, total: 25000, createdAt: new Date(Date.now() - 259200000).toISOString(), expectedDate: new Date(Date.now() + 172800000).toISOString() }
    ];
    res.json(purchaseOrders);
  } catch (error) {
    console.error('Get purchase orders error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/purchase-orders', verifyToken, async (req, res) => {
  try {
    const { supplier, items, total, expectedDate } = req.body;
    const newPO = {
      id: require('crypto').randomUUID(),
      poNumber: `PO-${Date.now().toString().slice(-6)}`,
      supplier,
      items: parseInt(items) || 0,
      total: parseFloat(total) || 0,
      expectedDate,
      createdAt: new Date().toISOString(),
      status: 'pending'
    };
    res.status(201).json(newPO);
  } catch (error) {
    console.error('Create purchase order error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// GET purchase order by ID
app.get('/api/purchase-orders/:id', verifyToken, async (req, res) => {
  try {
    const po = {
      id: req.params.id,
      poNumber: `PO-${req.params.id.slice(0, 6)}`,
      supplier: 'Sample Supplier',
      status: 'pending',
      items: 10,
      total: 5000,
      createdAt: new Date().toISOString(),
      expectedDate: new Date(Date.now() + 604800000).toISOString()
    };
    res.json(po);
  } catch (error) {
    console.error('Get purchase order by ID error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// UPDATE purchase order
app.put('/api/purchase-orders/:id', verifyToken, async (req, res) => {
  try {
    const { supplier, items, total, expectedDate, status } = req.body;
    const updatedPO = {
      id: req.params.id,
      poNumber: `PO-${req.params.id.slice(0, 6)}`,
      supplier: supplier || 'Sample Supplier',
      status: status || 'pending',
      items: parseInt(items) || 10,
      total: parseFloat(total) || 5000,
      createdAt: new Date().toISOString(),
      expectedDate: expectedDate || new Date(Date.now() + 604800000).toISOString(),
      updatedAt: new Date().toISOString()
    };
    res.json(updatedPO);
  } catch (error) {
    console.error('Update purchase order error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// DELETE purchase order
app.delete('/api/purchase-orders/:id', verifyToken, async (req, res) => {
  try {
    res.json({ success: true, message: 'Purchase order deleted' });
  } catch (error) {
    console.error('Delete purchase order error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// GOODS RECEIVING
// ===================================

app.get('/api/goods-receiving', verifyToken, async (req, res) => {
  try {
    const receivings = [
      { id: '1', grNumber: 'GR-001', poNumber: 'PO-001', supplier: 'Acme Supplies', status: 'pending', items: 10, receivedDate: null },
      { id: '2', grNumber: 'GR-002', poNumber: 'PO-002', supplier: 'Global Parts Inc', status: 'in_progress', items: 20, receivedDate: new Date().toISOString() },
      { id: '3', grNumber: 'GR-003', poNumber: 'PO-003', supplier: 'FastShip Co', status: 'completed', items: 15, receivedDate: new Date(Date.now() - 86400000).toISOString() },
      { id: '4', grNumber: 'GR-004', poNumber: 'PO-004', supplier: 'Quality Goods Ltd', status: 'partial', items: 30, receivedDate: new Date().toISOString() }
    ];
    res.json(receivings);
  } catch (error) {
    console.error('Get goods receiving error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/goods-receiving', verifyToken, async (req, res) => {
  try {
    const { poNumber, supplier, items } = req.body;
    const newGR = {
      id: require('crypto').randomUUID(),
      grNumber: `GR-${Date.now().toString().slice(-6)}`,
      poNumber,
      supplier,
      items: parseInt(items) || 0,
      receivedDate: null,
      status: 'pending'
    };
    res.status(201).json(newGR);
  } catch (error) {
    console.error('Create goods receiving error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// FBA TRANSFERS
// ===================================

app.get('/api/fba-transfers', verifyToken, async (req, res) => {
  try {
    const fbaTransfers = [
      { id: '1', transferId: 'FBA-001', destination: 'Amazon FBA - PHX3', status: 'pending', items: 100, pallets: 2, createdAt: new Date().toISOString() },
      { id: '2', transferId: 'FBA-002', destination: 'Amazon FBA - ONT8', status: 'in_transit', items: 250, pallets: 5, createdAt: new Date(Date.now() - 172800000).toISOString() },
      { id: '3', transferId: 'FBA-003', destination: 'Amazon FBA - SBD1', status: 'received', items: 75, pallets: 1, createdAt: new Date(Date.now() - 604800000).toISOString() },
      { id: '4', transferId: 'FBA-004', destination: 'Amazon FBA - LGB8', status: 'preparing', items: 500, pallets: 10, createdAt: new Date().toISOString() }
    ];
    res.json(fbaTransfers);
  } catch (error) {
    console.error('Get FBA transfers error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/fba-transfers', verifyToken, async (req, res) => {
  try {
    const { destination, items, pallets } = req.body;
    const newTransfer = {
      id: require('crypto').randomUUID(),
      transferId: `FBA-${Date.now().toString().slice(-6)}`,
      destination,
      items: parseInt(items) || 0,
      pallets: parseInt(pallets) || 0,
      createdAt: new Date().toISOString(),
      status: 'pending'
    };
    res.status(201).json(newTransfer);
  } catch (error) {
    console.error('Create FBA transfer error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// INTEGRATIONS
// ===================================

app.get('/api/integrations', verifyToken, async (req, res) => {
  try {
    const integrations = [
      { id: '1', name: 'Amazon Seller Central', type: 'marketplace', status: 'connected', lastSync: new Date().toISOString() },
      { id: '2', name: 'Shopify', type: 'ecommerce', status: 'connected', lastSync: new Date().toISOString() },
      { id: '3', name: 'QuickBooks', type: 'accounting', status: 'disconnected', lastSync: null },
      { id: '4', name: 'ShipStation', type: 'shipping', status: 'connected', lastSync: new Date(Date.now() - 3600000).toISOString() }
    ];
    res.json(integrations);
  } catch (error) {
    console.error('Get integrations error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/api/integrations/channels', verifyToken, async (req, res) => {
  try {
    const channels = [
      { id: '1', name: 'Amazon US', platform: 'Amazon', status: 'active', products: 150, orders: 45 },
      { id: '2', name: 'Shopify Store', platform: 'Shopify', status: 'active', products: 200, orders: 30 },
      { id: '3', name: 'eBay Store', platform: 'eBay', status: 'inactive', products: 75, orders: 0 },
      { id: '4', name: 'Walmart Marketplace', platform: 'Walmart', status: 'active', products: 100, orders: 20 }
    ];
    res.json(channels);
  } catch (error) {
    console.error('Get channels error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.get('/api/integrations/mappings', verifyToken, async (req, res) => {
  try {
    const mappings = [
      { id: '1', localSku: 'SKU-001', channelSku: 'AMZN-001', channel: 'Amazon US', status: 'mapped' },
      { id: '2', localSku: 'SKU-002', channelSku: 'SHOP-002', channel: 'Shopify', status: 'mapped' },
      { id: '3', localSku: 'SKU-003', channelSku: null, channel: null, status: 'unmapped' },
      { id: '4', localSku: 'SKU-004', channelSku: 'WMT-004', channel: 'Walmart', status: 'mapped' }
    ];
    res.json(mappings);
  } catch (error) {
    console.error('Get mappings error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// REPLENISHMENT SETTINGS
// ===================================

app.get('/api/replenishment/settings', verifyToken, async (req, res) => {
  try {
    const settings = {
      autoReplenish: true,
      lowStockThreshold: 10,
      reorderPoint: 20,
      maxStockLevel: 100,
      leadTimeDays: 7,
      safetyStockDays: 3,
      defaultSupplier: null
    };
    res.json(settings);
  } catch (error) {
    console.error('Get replenishment settings error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/replenishment/settings', verifyToken, async (req, res) => {
  try {
    const settings = req.body;
    res.json({ ...settings, updatedAt: new Date().toISOString() });
  } catch (error) {
    console.error('Update replenishment settings error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// ORDERS ENDPOINTS
// ===================================

// Get all orders (alias for sales-orders)
app.get('/api/orders', verifyToken, async (req, res) => {
  try {
    const orders = await prisma.salesOrder.findMany({
      where: {
        customer: { companyId: req.user.companyId }
      },
      include: {
        customer: true,
        items: {
          include: {
            product: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });
    res.json(orders);
  } catch (error) {
    console.error('Get orders error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// USERS MANAGEMENT ENDPOINTS
// ===================================

// Get all users
app.get('/api/users', verifyToken, async (req, res) => {
  try {
    const users = await prisma.user.findMany({
      where: { companyId: req.user.companyId },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        createdAt: true,
        updatedAt: true
      },
      orderBy: { createdAt: 'desc' }
    });
    res.json(users);
  } catch (error) {
    console.error('Get users error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get single user
app.get('/api/users/:id', verifyToken, async (req, res) => {
  try {
    const user = await prisma.user.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        isActive: true,
        createdAt: true,
        updatedAt: true
      }
    });
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Create user
app.post('/api/users', verifyToken, async (req, res) => {
  try {
    const { email, name, role, password } = req.body;

    const existingUser = await prisma.user.findUnique({ where: { email } });
    if (existingUser) {
      return res.status(409).json({ error: 'Email already exists' });
    }

    const hashedPassword = await bcrypt.hash(password || 'temppass123', 10);

    const user = await prisma.user.create({
      data: {
        id: require('crypto').randomUUID(),
        email,
        name,
        role: role || 'USER',
        password: hashedPassword,
        companyId: req.user.companyId,
        isActive: true
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        isActive: true,
        createdAt: true
      }
    });
    res.status(201).json(user);
  } catch (error) {
    console.error('Create user error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update user
app.put('/api/users/:id', verifyToken, async (req, res) => {
  try {
    const { name, role, isActive } = req.body;

    const user = await prisma.user.update({
      where: { id: req.params.id },
      data: {
        name,
        role,
        isActive,
        updatedAt: new Date()
      },
      select: {
        id: true,
        name: true,
        email: true,
        role: true,
        isActive: true,
        updatedAt: true
      }
    });
    res.json(user);
  } catch (error) {
    console.error('Update user error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Delete user
app.delete('/api/users/:id', verifyToken, async (req, res) => {
  try {
    await prisma.user.delete({ where: { id: req.params.id } });
    res.json({ message: 'User deleted successfully' });
  } catch (error) {
    console.error('Delete user error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// PICK LISTS ENDPOINTS
// ===================================

// Get all pick lists
app.get('/api/pick-lists', verifyToken, async (req, res) => {
  try {
    const pickLists = await prisma.pickList.findMany({
      where: { companyId: req.user.companyId },
      include: {
        items: {
          include: {
            product: true,
            location: true
          }
        },
        order: true,
        assignedTo: {
          select: { id: true, name: true, email: true }
        }
      },
      orderBy: { createdAt: 'desc' }
    });
    res.json(pickLists);
  } catch (error) {
    console.error('Get pick lists error:', error);
    // Return empty array if table doesn't exist yet
    res.json([]);
  }
});

// Create pick list
app.post('/api/pick-lists', verifyToken, async (req, res) => {
  try {
    const { orderId, items } = req.body;

    const pickList = await prisma.pickList.create({
      data: {
        id: require('crypto').randomUUID(),
        orderId,
        companyId: req.user.companyId,
        status: 'PENDING',
        items: {
          create: items.map(item => ({
            id: require('crypto').randomUUID(),
            productId: item.productId,
            locationId: item.locationId,
            quantity: item.quantity,
            pickedQuantity: 0,
            status: 'PENDING'
          }))
        }
      },
      include: {
        items: {
          include: {
            product: true,
            location: true
          }
        }
      }
    });
    res.status(201).json(pickList);
  } catch (error) {
    console.error('Create pick list error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// REPORTS ENDPOINTS
// ===================================

// Inventory Report
app.get('/api/reports/inventory', verifyToken, async (req, res) => {
  try {
    const inventory = await prisma.inventory.findMany({
      where: {
        warehouse: {
          companyId: req.user.companyId
        }
      },
      include: {
        product: true,
        warehouse: true,
        location: true
      }
    });

    const summary = {
      totalItems: inventory.length,
      totalQuantity: inventory.reduce((sum, inv) => sum + inv.quantity, 0),
      totalValue: inventory.reduce((sum, inv) => sum + (inv.quantity * (inv.product?.costPrice || 0)), 0),
      lowStockItems: inventory.filter(inv => inv.quantity < 10).length,
      byWarehouse: {},
      generatedAt: new Date().toISOString()
    };

    inventory.forEach(inv => {
      const warehouseName = inv.warehouse?.name || 'Unknown';
      if (!summary.byWarehouse[warehouseName]) {
        summary.byWarehouse[warehouseName] = { items: 0, quantity: 0 };
      }
      summary.byWarehouse[warehouseName].items++;
      summary.byWarehouse[warehouseName].quantity += inv.quantity;
    });

    res.json({ summary, details: inventory });
  } catch (error) {
    console.error('Get inventory report error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Sales Report
app.get('/api/reports/sales', verifyToken, async (req, res) => {
  try {
    const { startDate, endDate } = req.query;

    const whereClause = {
      customer: {
        companyId: req.user.companyId
      }
    };

    if (startDate && endDate) {
      whereClause.createdAt = {
        gte: new Date(startDate),
        lte: new Date(endDate)
      };
    }

    const orders = await prisma.salesOrder.findMany({
      where: whereClause,
      include: {
        customer: true,
        items: {
          include: { product: true }
        }
      }
    });

    const summary = {
      totalOrders: orders.length,
      totalRevenue: orders.reduce((sum, order) => sum + (order.totalAmount || 0), 0),
      averageOrderValue: orders.length > 0
        ? orders.reduce((sum, order) => sum + (order.totalAmount || 0), 0) / orders.length
        : 0,
      byStatus: {},
      topProducts: {},
      generatedAt: new Date().toISOString()
    };

    orders.forEach(order => {
      const status = order.status || 'UNKNOWN';
      summary.byStatus[status] = (summary.byStatus[status] || 0) + 1;

      order.items?.forEach(item => {
        const productName = item.product?.name || 'Unknown';
        if (!summary.topProducts[productName]) {
          summary.topProducts[productName] = { quantity: 0, revenue: 0 };
        }
        summary.topProducts[productName].quantity += item.quantity || 0;
        summary.topProducts[productName].revenue += (item.quantity || 0) * (item.unitPrice || 0);
      });
    });

    res.json({ summary, orders });
  } catch (error) {
    console.error('Get sales report error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Stock Movements Report
app.get('/api/reports/stock-movements', verifyToken, async (req, res) => {
  try {
    const movements = await prisma.inventoryMovement.findMany({
      where: {
        product: {
          companyId: req.user.companyId
        }
      },
      include: {
        product: true,
        fromLocation: true,
        toLocation: true,
        user: {
          select: { id: true, name: true, email: true }
        }
      },
      orderBy: { createdAt: 'desc' },
      take: 500
    });

    const summary = {
      totalMovements: movements.length,
      byType: {},
      byProduct: {},
      generatedAt: new Date().toISOString()
    };

    movements.forEach(mov => {
      const type = mov.type || 'UNKNOWN';
      summary.byType[type] = (summary.byType[type] || 0) + 1;

      const productName = mov.product?.name || 'Unknown';
      summary.byProduct[productName] = (summary.byProduct[productName] || 0) + 1;
    });

    res.json({ summary, movements });
  } catch (error) {
    console.error('Get stock movements report error:', error);
    // Return empty if model doesn't exist
    res.json({
      summary: { totalMovements: 0, byType: {}, byProduct: {}, generatedAt: new Date().toISOString() },
      movements: []
    });
  }
});

// Reports Summary - Combined overview of all reports
app.get('/api/reports/summary', verifyToken, async (req, res) => {
  try {
    // Get inventory summary
    const inventory = await prisma.inventory.findMany({
      where: {
        warehouse: {
          companyId: req.user.companyId
        }
      },
      include: { product: true }
    });

    // Get orders summary
    const orders = await prisma.salesOrder.findMany({
      where: {
        customer: {
          companyId: req.user.companyId
        }
      }
    });

    // Get products count
    const productsCount = await prisma.product.count({
      where: { companyId: req.user.companyId }
    });

    // Get customers count
    const customersCount = await prisma.customer.count({
      where: { companyId: req.user.companyId }
    });

    // Get suppliers count
    const suppliersCount = await prisma.supplier.count({
      where: { companyId: req.user.companyId }
    });

    const summary = {
      inventory: {
        totalItems: inventory.length,
        totalQuantity: inventory.reduce((sum, inv) => sum + inv.quantity, 0),
        totalValue: inventory.reduce((sum, inv) => sum + (inv.quantity * (inv.product?.costPrice || 0)), 0),
        lowStockItems: inventory.filter(inv => inv.quantity < 10).length
      },
      sales: {
        totalOrders: orders.length,
        totalRevenue: orders.reduce((sum, order) => sum + (order.totalAmount || 0), 0),
        pendingOrders: orders.filter(o => o.status === 'PENDING').length,
        completedOrders: orders.filter(o => o.status === 'DELIVERED' || o.status === 'SHIPPED').length
      },
      entities: {
        products: productsCount,
        customers: customersCount,
        suppliers: suppliersCount
      },
      generatedAt: new Date().toISOString()
    };

    res.json(summary);
  } catch (error) {
    console.error('Get reports summary error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// STOCK VALUATION REPORT
// ===================================

app.get('/api/reports/stock-valuation', verifyToken, async (req, res) => {
  try {
    const inventory = await prisma.inventory.findMany({
      where: {
        warehouse: {
          companyId: req.user.companyId
        }
      },
      include: {
        product: true,
        warehouse: true
      }
    });

    // Calculate valuations using different methods
    let totalCostValue = 0;
    let totalRetailValue = 0;
    let totalAverageCostValue = 0;
    const byProduct = {};
    const byWarehouse = {};
    const byCategory = {};

    inventory.forEach(inv => {
      const costPrice = parseFloat(inv.product?.costPrice || 0);
      const sellingPrice = parseFloat(inv.product?.sellingPrice || 0);
      const quantity = inv.quantity || 0;

      const itemCostValue = quantity * costPrice;
      const itemRetailValue = quantity * sellingPrice;

      totalCostValue += itemCostValue;
      totalRetailValue += itemRetailValue;

      // Group by product
      const productName = inv.product?.name || 'Unknown';
      if (!byProduct[productName]) {
        byProduct[productName] = { quantity: 0, costValue: 0, retailValue: 0, sku: inv.product?.sku };
      }
      byProduct[productName].quantity += quantity;
      byProduct[productName].costValue += itemCostValue;
      byProduct[productName].retailValue += itemRetailValue;

      // Group by warehouse
      const warehouseName = inv.warehouse?.name || 'Unknown';
      if (!byWarehouse[warehouseName]) {
        byWarehouse[warehouseName] = { items: 0, quantity: 0, costValue: 0, retailValue: 0 };
      }
      byWarehouse[warehouseName].items++;
      byWarehouse[warehouseName].quantity += quantity;
      byWarehouse[warehouseName].costValue += itemCostValue;
      byWarehouse[warehouseName].retailValue += itemRetailValue;

      // Group by brand/category
      const brandId = inv.product?.brandId || 'uncategorized';
      if (!byCategory[brandId]) {
        byCategory[brandId] = { items: 0, quantity: 0, costValue: 0, retailValue: 0 };
      }
      byCategory[brandId].items++;
      byCategory[brandId].quantity += quantity;
      byCategory[brandId].costValue += itemCostValue;
      byCategory[brandId].retailValue += itemRetailValue;
    });

    // Sort products by value for top items
    const topProducts = Object.entries(byProduct)
      .map(([name, data]) => ({ name, ...data }))
      .sort((a, b) => b.costValue - a.costValue)
      .slice(0, 20);

    res.json({
      summary: {
        totalItems: inventory.length,
        totalQuantity: inventory.reduce((sum, inv) => sum + (inv.quantity || 0), 0),
        valuationMethods: {
          costBasis: {
            method: 'COST',
            description: 'Valuation based on purchase/cost price',
            totalValue: Math.round(totalCostValue * 100) / 100
          },
          retailBasis: {
            method: 'RETAIL',
            description: 'Valuation based on selling price',
            totalValue: Math.round(totalRetailValue * 100) / 100
          },
          averageCost: {
            method: 'AVERAGE_COST',
            description: 'Weighted average cost method',
            totalValue: Math.round(totalCostValue * 100) / 100
          }
        },
        potentialProfit: Math.round((totalRetailValue - totalCostValue) * 100) / 100,
        profitMargin: totalRetailValue > 0 ? Math.round(((totalRetailValue - totalCostValue) / totalRetailValue) * 10000) / 100 : 0,
        generatedAt: new Date().toISOString()
      },
      byWarehouse,
      topProducts,
      details: inventory.slice(0, 100).map(inv => ({
        id: inv.id,
        productName: inv.product?.name,
        sku: inv.product?.sku,
        warehouse: inv.warehouse?.name,
        quantity: inv.quantity,
        costPrice: inv.product?.costPrice,
        sellingPrice: inv.product?.sellingPrice,
        costValue: (inv.quantity || 0) * parseFloat(inv.product?.costPrice || 0),
        retailValue: (inv.quantity || 0) * parseFloat(inv.product?.sellingPrice || 0)
      }))
    });
  } catch (error) {
    console.error('Get stock valuation error:', error);
    res.status(500).json({ error: 'Failed to generate stock valuation report' });
  }
});

// ===================================
// ABC ANALYSIS (Inventory Classification)
// ===================================

app.get('/api/reports/abc-analysis', verifyToken, async (req, res) => {
  try {
    const inventory = await prisma.inventory.findMany({
      where: {
        warehouse: {
          companyId: req.user.companyId
        }
      },
      include: {
        product: true
      }
    });

    // Get sales data for consumption analysis
    const salesOrders = await prisma.salesOrder.findMany({
      where: {
        customer: { companyId: req.user.companyId }
      },
      include: {
        items: {
          include: { product: true }
        }
      }
    });

    // Calculate annual consumption value per product
    const productAnalysis = {};

    salesOrders.forEach(order => {
      order.items?.forEach(item => {
        const productId = item.productId;
        const productName = item.product?.name || 'Unknown';
        const value = (item.quantity || 0) * (item.unitPrice || 0);

        if (!productAnalysis[productId]) {
          productAnalysis[productId] = {
            id: productId,
            name: productName,
            sku: item.product?.sku,
            totalQuantitySold: 0,
            totalValue: 0,
            orderCount: 0,
            currentStock: 0,
            costPrice: item.product?.costPrice || 0
          };
        }
        productAnalysis[productId].totalQuantitySold += item.quantity || 0;
        productAnalysis[productId].totalValue += value;
        productAnalysis[productId].orderCount++;
      });
    });

    // Add current stock levels
    inventory.forEach(inv => {
      if (productAnalysis[inv.productId]) {
        productAnalysis[inv.productId].currentStock += inv.quantity || 0;
      }
    });

    // Convert to array and sort by value
    const sortedProducts = Object.values(productAnalysis)
      .sort((a, b) => b.totalValue - a.totalValue);

    // Calculate total value
    const totalValue = sortedProducts.reduce((sum, p) => sum + p.totalValue, 0);

    // Classify into ABC categories
    let cumulativeValue = 0;
    const classifiedProducts = sortedProducts.map((product, index) => {
      cumulativeValue += product.totalValue;
      const cumulativePercentage = totalValue > 0 ? (cumulativeValue / totalValue) * 100 : 0;

      let category;
      if (cumulativePercentage <= 80) {
        category = 'A'; // Top 80% of value
      } else if (cumulativePercentage <= 95) {
        category = 'B'; // Next 15% of value
      } else {
        category = 'C'; // Bottom 5% of value
      }

      return {
        ...product,
        category,
        valuePercentage: totalValue > 0 ? Math.round((product.totalValue / totalValue) * 10000) / 100 : 0,
        cumulativePercentage: Math.round(cumulativePercentage * 100) / 100,
        rank: index + 1
      };
    });

    // Summary statistics
    const categoryA = classifiedProducts.filter(p => p.category === 'A');
    const categoryB = classifiedProducts.filter(p => p.category === 'B');
    const categoryC = classifiedProducts.filter(p => p.category === 'C');

    res.json({
      summary: {
        totalProducts: classifiedProducts.length,
        totalValue: Math.round(totalValue * 100) / 100,
        categories: {
          A: {
            count: categoryA.length,
            percentage: classifiedProducts.length > 0 ? Math.round((categoryA.length / classifiedProducts.length) * 10000) / 100 : 0,
            totalValue: Math.round(categoryA.reduce((sum, p) => sum + p.totalValue, 0) * 100) / 100,
            description: 'High-value items - 80% of total value, require tight control'
          },
          B: {
            count: categoryB.length,
            percentage: classifiedProducts.length > 0 ? Math.round((categoryB.length / classifiedProducts.length) * 10000) / 100 : 0,
            totalValue: Math.round(categoryB.reduce((sum, p) => sum + p.totalValue, 0) * 100) / 100,
            description: 'Medium-value items - 15% of total value, moderate control'
          },
          C: {
            count: categoryC.length,
            percentage: classifiedProducts.length > 0 ? Math.round((categoryC.length / classifiedProducts.length) * 10000) / 100 : 0,
            totalValue: Math.round(categoryC.reduce((sum, p) => sum + p.totalValue, 0) * 100) / 100,
            description: 'Low-value items - 5% of total value, simple control'
          }
        },
        generatedAt: new Date().toISOString()
      },
      products: classifiedProducts
    });
  } catch (error) {
    console.error('Get ABC analysis error:', error);
    res.status(500).json({ error: 'Failed to generate ABC analysis' });
  }
});

// ===================================
// SHIPPING CARRIERS API
// ===================================

// In-memory storage for shipping carriers (in production, this would be in the database)
let shippingCarriers = [
  { id: '1', name: 'DHL Express', code: 'DHL', type: 'EXPRESS', status: 'active', trackingUrl: 'https://www.dhl.com/track?AWB={tracking}', apiConfigured: true, credentials: { apiKey: '***configured***' }, supportedServices: ['EXPRESS', 'ECONOMY', 'FREIGHT'], createdAt: new Date().toISOString() },
  { id: '2', name: 'FedEx', code: 'FEDEX', type: 'EXPRESS', status: 'active', trackingUrl: 'https://www.fedex.com/fedextrack/?trknbr={tracking}', apiConfigured: true, credentials: { apiKey: '***configured***' }, supportedServices: ['PRIORITY', 'STANDARD', 'FREIGHT'], createdAt: new Date().toISOString() },
  { id: '3', name: 'UPS', code: 'UPS', type: 'EXPRESS', status: 'active', trackingUrl: 'https://www.ups.com/track?tracknum={tracking}', apiConfigured: true, credentials: { apiKey: '***configured***' }, supportedServices: ['NEXT_DAY', 'GROUND', 'FREIGHT'], createdAt: new Date().toISOString() },
  { id: '4', name: 'Royal Mail', code: 'ROYALMAIL', type: 'POSTAL', status: 'active', trackingUrl: 'https://www.royalmail.com/track-your-item/{tracking}', apiConfigured: false, credentials: null, supportedServices: ['FIRST_CLASS', 'SECOND_CLASS', 'SIGNED_FOR'], createdAt: new Date().toISOString() },
  { id: '5', name: 'Amazon Logistics', code: 'AMZL', type: 'FBA', status: 'active', trackingUrl: 'https://track.amazon.com/{tracking}', apiConfigured: true, credentials: { apiKey: '***configured***' }, supportedServices: ['STANDARD', 'SAME_DAY', 'NEXT_DAY'], createdAt: new Date().toISOString() }
];

app.get('/api/shipping/carriers', verifyToken, async (req, res) => {
  try {
    res.json(shippingCarriers);
  } catch (error) {
    console.error('Get shipping carriers error:', error);
    res.status(500).json({ error: 'Failed to get shipping carriers' });
  }
});

app.get('/api/shipping/carriers/:id', verifyToken, async (req, res) => {
  try {
    const carrier = shippingCarriers.find(c => c.id === req.params.id);
    if (!carrier) {
      return res.status(404).json({ error: 'Carrier not found' });
    }
    res.json(carrier);
  } catch (error) {
    console.error('Get shipping carrier error:', error);
    res.status(500).json({ error: 'Failed to get carrier' });
  }
});

app.post('/api/shipping/carriers', verifyToken, async (req, res) => {
  try {
    const { name, code, type, trackingUrl, credentials, supportedServices } = req.body;

    if (!name || !code) {
      return res.status(400).json({ error: 'Name and code are required' });
    }

    const newCarrier = {
      id: String(Date.now()),
      name,
      code: code.toUpperCase(),
      type: type || 'STANDARD',
      status: 'active',
      trackingUrl: trackingUrl || '',
      apiConfigured: !!credentials,
      credentials: credentials ? { apiKey: '***configured***' } : null,
      supportedServices: supportedServices || ['STANDARD'],
      createdAt: new Date().toISOString()
    };

    shippingCarriers.push(newCarrier);
    res.status(201).json(newCarrier);
  } catch (error) {
    console.error('Create shipping carrier error:', error);
    res.status(500).json({ error: 'Failed to create carrier' });
  }
});

app.put('/api/shipping/carriers/:id', verifyToken, async (req, res) => {
  try {
    const index = shippingCarriers.findIndex(c => c.id === req.params.id);
    if (index === -1) {
      return res.status(404).json({ error: 'Carrier not found' });
    }

    const { name, code, type, status, trackingUrl, credentials, supportedServices } = req.body;

    shippingCarriers[index] = {
      ...shippingCarriers[index],
      ...(name && { name }),
      ...(code && { code: code.toUpperCase() }),
      ...(type && { type }),
      ...(status && { status }),
      ...(trackingUrl !== undefined && { trackingUrl }),
      ...(credentials !== undefined && { apiConfigured: !!credentials, credentials: credentials ? { apiKey: '***configured***' } : null }),
      ...(supportedServices && { supportedServices }),
      updatedAt: new Date().toISOString()
    };

    res.json(shippingCarriers[index]);
  } catch (error) {
    console.error('Update shipping carrier error:', error);
    res.status(500).json({ error: 'Failed to update carrier' });
  }
});

app.delete('/api/shipping/carriers/:id', verifyToken, async (req, res) => {
  try {
    const index = shippingCarriers.findIndex(c => c.id === req.params.id);
    if (index === -1) {
      return res.status(404).json({ error: 'Carrier not found' });
    }

    shippingCarriers.splice(index, 1);
    res.json({ message: 'Carrier deleted successfully' });
  } catch (error) {
    console.error('Delete shipping carrier error:', error);
    res.status(500).json({ error: 'Failed to delete carrier' });
  }
});

// Get shipping rates from carrier
app.post('/api/shipping/rates', verifyToken, async (req, res) => {
  try {
    const { carrierId, origin, destination, weight, dimensions } = req.body;

    // Simulated rate calculation
    const baseRates = {
      DHL: { EXPRESS: 25.99, ECONOMY: 12.99, FREIGHT: 89.99 },
      FEDEX: { PRIORITY: 29.99, STANDARD: 14.99, FREIGHT: 99.99 },
      UPS: { NEXT_DAY: 34.99, GROUND: 9.99, FREIGHT: 79.99 },
      ROYALMAIL: { FIRST_CLASS: 3.99, SECOND_CLASS: 2.49, SIGNED_FOR: 5.99 },
      AMZL: { STANDARD: 4.99, SAME_DAY: 9.99, NEXT_DAY: 7.99 }
    };

    const carrier = shippingCarriers.find(c => c.id === carrierId);
    if (!carrier) {
      return res.status(404).json({ error: 'Carrier not found' });
    }

    const rates = carrier.supportedServices.map(service => ({
      service,
      carrier: carrier.name,
      estimatedDays: service.includes('EXPRESS') || service.includes('NEXT_DAY') || service.includes('SAME_DAY') ? 1 : service.includes('STANDARD') ? 3 : 5,
      price: (baseRates[carrier.code]?.[service] || 15.99) + (weight || 1) * 0.5,
      currency: 'USD'
    }));

    res.json({ carrier: carrier.name, rates });
  } catch (error) {
    console.error('Get shipping rates error:', error);
    res.status(500).json({ error: 'Failed to get rates' });
  }
});

// ===================================
// WEBHOOKS API
// ===================================

// In-memory storage for webhooks
let webhooks = [
  { id: '1', name: 'Order Created Webhook', url: 'https://example.com/webhooks/order-created', events: ['order.created'], status: 'active', secret: 'whsec_***', lastTriggered: null, successCount: 0, failureCount: 0, createdAt: new Date().toISOString() },
  { id: '2', name: 'Inventory Low Stock Alert', url: 'https://example.com/webhooks/low-stock', events: ['inventory.low_stock'], status: 'active', secret: 'whsec_***', lastTriggered: null, successCount: 0, failureCount: 0, createdAt: new Date().toISOString() },
  { id: '3', name: 'Shipment Tracking Update', url: 'https://example.com/webhooks/shipment-update', events: ['shipment.created', 'shipment.delivered'], status: 'inactive', secret: 'whsec_***', lastTriggered: null, successCount: 0, failureCount: 0, createdAt: new Date().toISOString() }
];

const availableWebhookEvents = [
  { event: 'order.created', description: 'Fired when a new order is created' },
  { event: 'order.updated', description: 'Fired when an order is updated' },
  { event: 'order.shipped', description: 'Fired when an order is shipped' },
  { event: 'order.delivered', description: 'Fired when an order is delivered' },
  { event: 'order.cancelled', description: 'Fired when an order is cancelled' },
  { event: 'inventory.updated', description: 'Fired when inventory levels change' },
  { event: 'inventory.low_stock', description: 'Fired when inventory falls below threshold' },
  { event: 'inventory.out_of_stock', description: 'Fired when inventory reaches zero' },
  { event: 'product.created', description: 'Fired when a new product is created' },
  { event: 'product.updated', description: 'Fired when a product is updated' },
  { event: 'shipment.created', description: 'Fired when a shipment is created' },
  { event: 'shipment.delivered', description: 'Fired when a shipment is delivered' },
  { event: 'customer.created', description: 'Fired when a new customer is created' },
  { event: 'return.created', description: 'Fired when a return is initiated' }
];

app.get('/api/webhooks', verifyToken, async (req, res) => {
  try {
    res.json(webhooks);
  } catch (error) {
    console.error('Get webhooks error:', error);
    res.status(500).json({ error: 'Failed to get webhooks' });
  }
});

app.get('/api/webhooks/events', verifyToken, async (req, res) => {
  try {
    res.json(availableWebhookEvents);
  } catch (error) {
    console.error('Get webhook events error:', error);
    res.status(500).json({ error: 'Failed to get events' });
  }
});

app.get('/api/webhooks/:id', verifyToken, async (req, res) => {
  try {
    const webhook = webhooks.find(w => w.id === req.params.id);
    if (!webhook) {
      return res.status(404).json({ error: 'Webhook not found' });
    }
    res.json(webhook);
  } catch (error) {
    console.error('Get webhook error:', error);
    res.status(500).json({ error: 'Failed to get webhook' });
  }
});

app.post('/api/webhooks', verifyToken, async (req, res) => {
  try {
    const { name, url, events } = req.body;

    if (!name || !url || !events || events.length === 0) {
      return res.status(400).json({ error: 'Name, URL, and at least one event are required' });
    }

    // Validate URL
    try {
      new URL(url);
    } catch {
      return res.status(400).json({ error: 'Invalid URL format' });
    }

    // Generate webhook secret
    const secret = 'whsec_' + require('crypto').randomBytes(24).toString('hex');

    const newWebhook = {
      id: String(Date.now()),
      name,
      url,
      events,
      status: 'active',
      secret,
      lastTriggered: null,
      successCount: 0,
      failureCount: 0,
      createdAt: new Date().toISOString()
    };

    webhooks.push(newWebhook);
    res.status(201).json(newWebhook);
  } catch (error) {
    console.error('Create webhook error:', error);
    res.status(500).json({ error: 'Failed to create webhook' });
  }
});

app.put('/api/webhooks/:id', verifyToken, async (req, res) => {
  try {
    const index = webhooks.findIndex(w => w.id === req.params.id);
    if (index === -1) {
      return res.status(404).json({ error: 'Webhook not found' });
    }

    const { name, url, events, status } = req.body;

    if (url) {
      try {
        new URL(url);
      } catch {
        return res.status(400).json({ error: 'Invalid URL format' });
      }
    }

    webhooks[index] = {
      ...webhooks[index],
      ...(name && { name }),
      ...(url && { url }),
      ...(events && { events }),
      ...(status && { status }),
      updatedAt: new Date().toISOString()
    };

    res.json(webhooks[index]);
  } catch (error) {
    console.error('Update webhook error:', error);
    res.status(500).json({ error: 'Failed to update webhook' });
  }
});

app.delete('/api/webhooks/:id', verifyToken, async (req, res) => {
  try {
    const index = webhooks.findIndex(w => w.id === req.params.id);
    if (index === -1) {
      return res.status(404).json({ error: 'Webhook not found' });
    }

    webhooks.splice(index, 1);
    res.json({ message: 'Webhook deleted successfully' });
  } catch (error) {
    console.error('Delete webhook error:', error);
    res.status(500).json({ error: 'Failed to delete webhook' });
  }
});

// Test webhook endpoint
app.post('/api/webhooks/:id/test', verifyToken, async (req, res) => {
  try {
    const webhook = webhooks.find(w => w.id === req.params.id);
    if (!webhook) {
      return res.status(404).json({ error: 'Webhook not found' });
    }

    // Simulate webhook test
    const testPayload = {
      event: 'test',
      timestamp: new Date().toISOString(),
      data: {
        message: 'This is a test webhook from Kiaan WMS',
        webhookId: webhook.id
      }
    };

    // In production, this would actually send the request
    // For now, we simulate success
    const index = webhooks.findIndex(w => w.id === req.params.id);
    webhooks[index].lastTriggered = new Date().toISOString();
    webhooks[index].successCount++;

    res.json({
      success: true,
      message: 'Test webhook sent successfully',
      payload: testPayload
    });
  } catch (error) {
    console.error('Test webhook error:', error);
    res.status(500).json({ error: 'Failed to test webhook' });
  }
});

// ===================================
// LOW STOCK ALERTS
// ===================================

app.get('/api/reports/low-stock', verifyToken, async (req, res) => {
  try {
    const { threshold = 10 } = req.query;

    const inventory = await prisma.inventory.findMany({
      where: {
        warehouse: {
          companyId: req.user.companyId
        },
        quantity: {
          lte: parseInt(threshold)
        }
      },
      include: {
        product: true,
        warehouse: true
      },
      orderBy: {
        quantity: 'asc'
      }
    });

    const alerts = inventory.map(inv => ({
      id: inv.id,
      productId: inv.productId,
      productName: inv.product?.name,
      sku: inv.product?.sku,
      warehouse: inv.warehouse?.name,
      currentQuantity: inv.quantity,
      threshold: parseInt(threshold),
      status: inv.quantity === 0 ? 'OUT_OF_STOCK' : inv.quantity <= parseInt(threshold) / 2 ? 'CRITICAL' : 'LOW',
      reorderSuggestion: Math.max(50, parseInt(threshold) * 3),
      estimatedValue: (inv.quantity || 0) * parseFloat(inv.product?.costPrice || 0)
    }));

    res.json({
      summary: {
        totalAlerts: alerts.length,
        outOfStock: alerts.filter(a => a.status === 'OUT_OF_STOCK').length,
        critical: alerts.filter(a => a.status === 'CRITICAL').length,
        low: alerts.filter(a => a.status === 'LOW').length,
        threshold: parseInt(threshold),
        generatedAt: new Date().toISOString()
      },
      alerts
    });
  } catch (error) {
    console.error('Get low stock alerts error:', error);
    res.status(500).json({ error: 'Failed to get low stock alerts' });
  }
});

// ===================================
// SETTINGS ENDPOINTS
// ===================================

// Get company settings
app.get('/api/settings', verifyToken, async (req, res) => {
  try {
    const company = await prisma.company.findUnique({
      where: { id: req.user.companyId }
    });

    if (!company) {
      return res.status(404).json({ error: 'Company not found' });
    }

    // Return comprehensive settings object
    res.json({
      id: company.id,
      name: company.name,
      email: company.email || '',
      phone: company.phone || '',
      address: company.address || '',

      // General Settings
      currency: company.currency || 'USD',
      timezone: company.timezone || 'UTC',
      dateFormat: company.dateFormat || 'YYYY-MM-DD',
      logo: company.logo || null,

      // Notification Settings
      emailNotifications: company.emailNotifications !== false,
      lowStockAlerts: company.lowStockAlerts !== false,
      orderConfirmations: company.orderConfirmations !== false,

      // Inventory Settings
      defaultWarehouse: company.defaultWarehouse || null,
      autoReorderEnabled: company.autoReorderEnabled || false,
      batchTrackingEnabled: company.batchTrackingEnabled !== false,
      expiryTrackingEnabled: company.expiryTrackingEnabled !== false,
      lowStockThreshold: company.lowStockThreshold || 10,
      defaultTaxRate: company.defaultTaxRate || 0,

      createdAt: company.createdAt,
      updatedAt: company.updatedAt
    });
  } catch (error) {
    console.error('Get settings error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update company settings
app.put('/api/settings', verifyToken, async (req, res) => {
  try {
    const {
      name, email, phone, address, currency, timezone, dateFormat, logo,
      emailNotifications, lowStockAlerts, orderConfirmations,
      defaultWarehouse, autoReorderEnabled, batchTrackingEnabled,
      expiryTrackingEnabled, lowStockThreshold, defaultTaxRate
    } = req.body;

    const updateData = {};

    // General settings
    if (name !== undefined) updateData.name = name;
    if (email !== undefined) updateData.email = email;
    if (phone !== undefined) updateData.phone = phone;
    if (address !== undefined) updateData.address = address;
    if (currency !== undefined) updateData.currency = currency;
    if (timezone !== undefined) updateData.timezone = timezone;
    if (dateFormat !== undefined) updateData.dateFormat = dateFormat;
    if (logo !== undefined) updateData.logo = logo;

    // Notification settings
    if (emailNotifications !== undefined) updateData.emailNotifications = emailNotifications;
    if (lowStockAlerts !== undefined) updateData.lowStockAlerts = lowStockAlerts;
    if (orderConfirmations !== undefined) updateData.orderConfirmations = orderConfirmations;

    // Inventory settings
    if (defaultWarehouse !== undefined) updateData.defaultWarehouse = defaultWarehouse;
    if (autoReorderEnabled !== undefined) updateData.autoReorderEnabled = autoReorderEnabled;
    if (batchTrackingEnabled !== undefined) updateData.batchTrackingEnabled = batchTrackingEnabled;
    if (expiryTrackingEnabled !== undefined) updateData.expiryTrackingEnabled = expiryTrackingEnabled;
    if (lowStockThreshold !== undefined) updateData.lowStockThreshold = parseInt(lowStockThreshold);
    if (defaultTaxRate !== undefined) updateData.defaultTaxRate = parseFloat(defaultTaxRate);

    const company = await prisma.company.update({
      where: { id: req.user.companyId },
      data: updateData
    });

    res.json({
      id: company.id,
      name: company.name,
      email: company.email || '',
      phone: company.phone || '',
      address: company.address || '',
      currency: company.currency || 'USD',
      timezone: company.timezone || 'UTC',
      dateFormat: company.dateFormat || 'YYYY-MM-DD',
      logo: company.logo || null,
      emailNotifications: company.emailNotifications,
      lowStockAlerts: company.lowStockAlerts,
      orderConfirmations: company.orderConfirmations,
      defaultWarehouse: company.defaultWarehouse,
      autoReorderEnabled: company.autoReorderEnabled,
      batchTrackingEnabled: company.batchTrackingEnabled,
      expiryTrackingEnabled: company.expiryTrackingEnabled,
      lowStockThreshold: company.lowStockThreshold,
      defaultTaxRate: company.defaultTaxRate,
      updatedAt: company.updatedAt
    });
  } catch (error) {
    console.error('Update settings error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// ANALYTICS ENDPOINTS
// ===================================

// Revenue by Channel
app.get('/api/analytics/revenue-by-channel', verifyToken, async (req, res) => {
  try {
    const orders = await prisma.salesOrder.findMany({
      where: { companyId: req.user.companyId },
      select: {
        channel: true,
        totalAmount: true,
        createdAt: true
      }
    });

    const byChannel = {};
    orders.forEach(order => {
      const channel = order.channel || 'Direct';
      if (!byChannel[channel]) {
        byChannel[channel] = { revenue: 0, orders: 0 };
      }
      byChannel[channel].revenue += order.totalAmount || 0;
      byChannel[channel].orders++;
    });

    const result = Object.entries(byChannel).map(([channel, data]) => ({
      channel,
      revenue: data.revenue,
      orders: data.orders,
      averageOrderValue: data.orders > 0 ? data.revenue / data.orders : 0
    }));

    res.json(result);
  } catch (error) {
    console.error('Get revenue by channel error:', error);
    res.json([]);
  }
});

// Sales Trends
app.get('/api/analytics/sales-trends', verifyToken, async (req, res) => {
  try {
    const { period = '30' } = req.query;
    const daysAgo = parseInt(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - daysAgo);

    const orders = await prisma.salesOrder.findMany({
      where: {
        companyId: req.user.companyId,
        createdAt: { gte: startDate }
      },
      select: {
        totalAmount: true,
        createdAt: true,
        status: true
      },
      orderBy: { createdAt: 'asc' }
    });

    // Group by date
    const byDate = {};
    orders.forEach(order => {
      const date = order.createdAt.toISOString().split('T')[0];
      if (!byDate[date]) {
        byDate[date] = { revenue: 0, orders: 0 };
      }
      byDate[date].revenue += order.totalAmount || 0;
      byDate[date].orders++;
    });

    const trends = Object.entries(byDate).map(([date, data]) => ({
      date,
      revenue: data.revenue,
      orders: data.orders
    })).sort((a, b) => a.date.localeCompare(b.date));

    res.json({
      period: `${daysAgo} days`,
      totalRevenue: orders.reduce((sum, o) => sum + (o.totalAmount || 0), 0),
      totalOrders: orders.length,
      trends
    });
  } catch (error) {
    console.error('Get sales trends error:', error);
    res.json({ period: '30 days', totalRevenue: 0, totalOrders: 0, trends: [] });
  }
});

// ===================================
// WAREHOUSES - Full CRUD
// ===================================

// GET single warehouse
app.get('/api/warehouses/:id', verifyToken, async (req, res) => {
  try {
    const warehouse = await prisma.warehouse.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      },
      include: {
        zones: true,
        locations: true,
        _count: {
          select: { inventory: true, locations: true }
        }
      }
    });
    if (!warehouse) {
      return res.status(404).json({ error: 'Warehouse not found' });
    }
    res.json(warehouse);
  } catch (error) {
    console.error('Get warehouse error:', error);
    res.status(500).json({ error: 'Failed to get warehouse' });
  }
});

// CREATE warehouse
app.post('/api/warehouses', verifyToken, async (req, res) => {
  try {
    const { name, code, type, address, phone, capacity, status } = req.body;

    if (!name || !code) {
      return res.status(400).json({ error: 'Name and code are required' });
    }

    const warehouse = await prisma.warehouse.create({
      data: {
        name,
        code,
        type: type || 'MAIN',
        address,
        phone,
        capacity: capacity ? parseInt(capacity) : null,
        status: status || 'ACTIVE',
        companyId: req.user.companyId
      }
    });
    res.status(201).json(warehouse);
  } catch (error) {
    console.error('Create warehouse error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Warehouse code already exists' });
    }
    res.status(500).json({ error: 'Failed to create warehouse' });
  }
});

// UPDATE warehouse
app.put('/api/warehouses/:id', verifyToken, async (req, res) => {
  try {
    const { name, code, type, address, phone, capacity, status } = req.body;

    const existing = await prisma.warehouse.findFirst({
      where: { id: req.params.id, companyId: req.user.companyId }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Warehouse not found' });
    }

    const warehouse = await prisma.warehouse.update({
      where: { id: req.params.id },
      data: {
        ...(name && { name }),
        ...(code && { code }),
        ...(type && { type }),
        ...(address !== undefined && { address }),
        ...(phone !== undefined && { phone }),
        ...(capacity !== undefined && { capacity: capacity ? parseInt(capacity) : null }),
        ...(status && { status })
      }
    });
    res.json(warehouse);
  } catch (error) {
    console.error('Update warehouse error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Warehouse code already exists' });
    }
    res.status(500).json({ error: 'Failed to update warehouse' });
  }
});

// DELETE warehouse
app.delete('/api/warehouses/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.warehouse.findFirst({
      where: { id: req.params.id, companyId: req.user.companyId },
      include: { _count: { select: { inventory: true } } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Warehouse not found' });
    }
    if (existing._count.inventory > 0) {
      return res.status(400).json({ error: 'Cannot delete warehouse with inventory' });
    }

    await prisma.warehouse.delete({ where: { id: req.params.id } });
    res.json({ message: 'Warehouse deleted successfully' });
  } catch (error) {
    console.error('Delete warehouse error:', error);
    res.status(500).json({ error: 'Failed to delete warehouse' });
  }
});

// ===================================
// CUSTOMERS - Full CRUD
// ===================================

// GET single customer
app.get('/api/customers/:id', verifyToken, async (req, res) => {
  try {
    const customer = await prisma.customer.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      },
      include: {
        orders: {
          take: 10,
          orderBy: { createdAt: 'desc' }
        },
        _count: { select: { orders: true } }
      }
    });
    if (!customer) {
      return res.status(404).json({ error: 'Customer not found' });
    }
    res.json(customer);
  } catch (error) {
    console.error('Get customer error:', error);
    res.status(500).json({ error: 'Failed to get customer' });
  }
});

// CREATE customer
app.post('/api/customers', verifyToken, async (req, res) => {
  try {
    const { name, code, email, phone, address, customerType } = req.body;

    if (!name || !code) {
      return res.status(400).json({ error: 'Name and code are required' });
    }

    const customer = await prisma.customer.create({
      data: {
        name,
        code,
        email,
        phone,
        address,
        customerType: customerType || 'B2C',
        companyId: req.user.companyId
      }
    });
    res.status(201).json(customer);
  } catch (error) {
    console.error('Create customer error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Customer code already exists' });
    }
    res.status(500).json({ error: 'Failed to create customer' });
  }
});

// UPDATE customer
app.put('/api/customers/:id', verifyToken, async (req, res) => {
  try {
    const { name, code, email, phone, address, customerType } = req.body;

    const existing = await prisma.customer.findFirst({
      where: { id: req.params.id, companyId: req.user.companyId }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Customer not found' });
    }

    const customer = await prisma.customer.update({
      where: { id: req.params.id },
      data: {
        ...(name && { name }),
        ...(code && { code }),
        ...(email !== undefined && { email }),
        ...(phone !== undefined && { phone }),
        ...(address !== undefined && { address }),
        ...(customerType && { customerType })
      }
    });
    res.json(customer);
  } catch (error) {
    console.error('Update customer error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Customer code already exists' });
    }
    res.status(500).json({ error: 'Failed to update customer' });
  }
});

// DELETE customer
app.delete('/api/customers/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.customer.findFirst({
      where: { id: req.params.id, companyId: req.user.companyId },
      include: { _count: { select: { orders: true } } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Customer not found' });
    }
    if (existing._count.orders > 0) {
      return res.status(400).json({ error: 'Cannot delete customer with orders' });
    }

    await prisma.customer.delete({ where: { id: req.params.id } });
    res.json({ message: 'Customer deleted successfully' });
  } catch (error) {
    console.error('Delete customer error:', error);
    res.status(500).json({ error: 'Failed to delete customer' });
  }
});

// ===================================
// CATEGORIES - Full CRUD
// ===================================

// GET single category
app.get('/api/categories/:id', verifyToken, async (req, res) => {
  try {
    const category = await prisma.brand.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      },
      include: {
        _count: { select: { products: true } }
      }
    });
    if (!category) {
      return res.status(404).json({ error: 'Category not found' });
    }
    res.json(category);
  } catch (error) {
    console.error('Get category error:', error);
    res.status(500).json({ error: 'Failed to get category' });
  }
});

// CREATE category
app.post('/api/categories', verifyToken, async (req, res) => {
  try {
    const { name, code, description } = req.body;

    if (!name || !code) {
      return res.status(400).json({ error: 'Name and code are required' });
    }

    const category = await prisma.brand.create({
      data: {
        name,
        code,
        description,
        companyId: req.user.companyId
      }
    });
    res.status(201).json(category);
  } catch (error) {
    console.error('Create category error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Category code already exists' });
    }
    res.status(500).json({ error: 'Failed to create category' });
  }
});

// UPDATE category
app.put('/api/categories/:id', verifyToken, async (req, res) => {
  try {
    const { name, code, description } = req.body;

    const existing = await prisma.brand.findFirst({
      where: { id: req.params.id, companyId: req.user.companyId }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Category not found' });
    }

    const category = await prisma.brand.update({
      where: { id: req.params.id },
      data: {
        ...(name && { name }),
        ...(code && { code }),
        ...(description !== undefined && { description })
      }
    });
    res.json(category);
  } catch (error) {
    console.error('Update category error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Category code already exists' });
    }
    res.status(500).json({ error: 'Failed to update category' });
  }
});

// DELETE category
app.delete('/api/categories/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.brand.findFirst({
      where: { id: req.params.id, companyId: req.user.companyId },
      include: { _count: { select: { products: true } } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Category not found' });
    }
    if (existing._count.products > 0) {
      return res.status(400).json({ error: 'Cannot delete category with products' });
    }

    await prisma.brand.delete({ where: { id: req.params.id } });
    res.json({ message: 'Category deleted successfully' });
  } catch (error) {
    console.error('Delete category error:', error);
    res.status(500).json({ error: 'Failed to delete category' });
  }
});

// ===================================
// SALES ORDERS - Full CRUD
// ===================================

// GET single sales order
app.get('/api/sales-orders/:id', verifyToken, async (req, res) => {
  try {
    const order = await prisma.salesOrder.findFirst({
      where: { id: req.params.id },
      include: {
        customer: true,
        items: {
          include: { product: true }
        },
        pickLists: true
      }
    });
    if (!order) {
      return res.status(404).json({ error: 'Sales order not found' });
    }
    res.json(order);
  } catch (error) {
    console.error('Get sales order error:', error);
    res.status(500).json({ error: 'Failed to get sales order' });
  }
});

// UPDATE sales order
app.put('/api/sales-orders/:id', verifyToken, async (req, res) => {
  try {
    const { status, priority, isWholesale, shippingAddress, shippingMethod, notes, trackingNumber } = req.body;

    const existing = await prisma.salesOrder.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Sales order not found' });
    }

    const order = await prisma.salesOrder.update({
      where: { id: req.params.id },
      data: {
        ...(status && { status }),
        ...(priority && { priority }),
        ...(isWholesale !== undefined && { isWholesale }),
        ...(shippingAddress !== undefined && { shippingAddress }),
        ...(shippingMethod !== undefined && { shippingMethod }),
        ...(notes !== undefined && { notes }),
        ...(trackingNumber !== undefined && { trackingNumber }),
        ...(status === 'SHIPPED' && { shippedDate: new Date() })
      },
      include: {
        customer: true,
        items: { include: { product: true } }
      }
    });
    res.json(order);
  } catch (error) {
    console.error('Update sales order error:', error);
    res.status(500).json({ error: 'Failed to update sales order' });
  }
});

// DELETE sales order
app.delete('/api/sales-orders/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.salesOrder.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Sales order not found' });
    }
    if (!['PENDING', 'CANCELLED'].includes(existing.status)) {
      return res.status(400).json({ error: 'Can only delete pending or cancelled orders' });
    }

    // Delete order items first
    await prisma.salesOrderItem.deleteMany({ where: { orderId: req.params.id } });
    await prisma.salesOrder.delete({ where: { id: req.params.id } });
    res.json({ message: 'Sales order deleted successfully' });
  } catch (error) {
    console.error('Delete sales order error:', error);
    res.status(500).json({ error: 'Failed to delete sales order' });
  }
});

// ===================================
// TRANSFERS - Full CRUD
// ===================================

// GET single transfer
app.get('/api/transfers/:id', verifyToken, async (req, res) => {
  try {
    const transfer = await prisma.transfer.findUnique({
      where: { id: req.params.id },
      include: {
        fromWarehouse: true,
        toWarehouse: true,
        items: true
      }
    });
    if (!transfer) {
      return res.status(404).json({ error: 'Transfer not found' });
    }
    res.json(transfer);
  } catch (error) {
    console.error('Get transfer error:', error);
    res.status(500).json({ error: 'Failed to get transfer' });
  }
});

// UPDATE transfer
app.put('/api/transfers/:id', verifyToken, async (req, res) => {
  try {
    const { status, notes, fbaShipmentId, fbaDestination, shipmentBuilt } = req.body;

    const existing = await prisma.transfer.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Transfer not found' });
    }

    const transfer = await prisma.transfer.update({
      where: { id: req.params.id },
      data: {
        ...(status && { status }),
        ...(notes !== undefined && { notes }),
        ...(fbaShipmentId !== undefined && { fbaShipmentId }),
        ...(fbaDestination !== undefined && { fbaDestination }),
        ...(shipmentBuilt !== undefined && { shipmentBuilt }),
        ...(status === 'IN_TRANSIT' && { shippedAt: new Date() }),
        ...(status === 'COMPLETED' && { receivedAt: new Date() })
      },
      include: {
        fromWarehouse: true,
        toWarehouse: true,
        items: true
      }
    });
    res.json(transfer);
  } catch (error) {
    console.error('Update transfer error:', error);
    res.status(500).json({ error: 'Failed to update transfer' });
  }
});

// DELETE transfer
app.delete('/api/transfers/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.transfer.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Transfer not found' });
    }
    if (!['PENDING', 'CANCELLED'].includes(existing.status)) {
      return res.status(400).json({ error: 'Can only delete pending or cancelled transfers' });
    }

    await prisma.transferItem.deleteMany({ where: { transferId: req.params.id } });
    await prisma.transfer.delete({ where: { id: req.params.id } });
    res.json({ message: 'Transfer deleted successfully' });
  } catch (error) {
    console.error('Delete transfer error:', error);
    res.status(500).json({ error: 'Failed to delete transfer' });
  }
});

// ===================================
// CHANNELS (Sales Channels) - Full CRUD
// ===================================

// GET single channel
app.get('/api/channels/:id', verifyToken, async (req, res) => {
  try {
    const channel = await prisma.salesChannel.findUnique({
      where: { id: req.params.id },
      include: {
        _count: { select: { channelPrices: true } }
      }
    });
    if (!channel) {
      return res.status(404).json({ error: 'Channel not found' });
    }
    res.json(channel);
  } catch (error) {
    console.error('Get channel error:', error);
    res.status(500).json({ error: 'Failed to get channel' });
  }
});

// CREATE channel
app.post('/api/channels', verifyToken, async (req, res) => {
  try {
    const { name, code, type, referralFeePercent, fixedFee, fulfillmentFeePerUnit, storageFeePerUnit, additionalFees, isActive } = req.body;

    if (!name || !code || !type) {
      return res.status(400).json({ error: 'Name, code, and type are required' });
    }

    const channel = await prisma.salesChannel.create({
      data: {
        name,
        code,
        type,
        referralFeePercent: referralFeePercent ? parseFloat(referralFeePercent) : null,
        fixedFee: fixedFee ? parseFloat(fixedFee) : null,
        fulfillmentFeePerUnit: fulfillmentFeePerUnit ? parseFloat(fulfillmentFeePerUnit) : null,
        storageFeePerUnit: storageFeePerUnit ? parseFloat(storageFeePerUnit) : null,
        additionalFees: additionalFees || null,
        isActive: isActive !== undefined ? isActive : true
      }
    });
    res.status(201).json(channel);
  } catch (error) {
    console.error('Create channel error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Channel code already exists' });
    }
    res.status(500).json({ error: 'Failed to create channel' });
  }
});

// UPDATE channel
app.put('/api/channels/:id', verifyToken, async (req, res) => {
  try {
    const { name, code, type, referralFeePercent, fixedFee, fulfillmentFeePerUnit, storageFeePerUnit, additionalFees, isActive } = req.body;

    const existing = await prisma.salesChannel.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Channel not found' });
    }

    const channel = await prisma.salesChannel.update({
      where: { id: req.params.id },
      data: {
        ...(name && { name }),
        ...(code && { code }),
        ...(type && { type }),
        ...(referralFeePercent !== undefined && { referralFeePercent: referralFeePercent ? parseFloat(referralFeePercent) : null }),
        ...(fixedFee !== undefined && { fixedFee: fixedFee ? parseFloat(fixedFee) : null }),
        ...(fulfillmentFeePerUnit !== undefined && { fulfillmentFeePerUnit: fulfillmentFeePerUnit ? parseFloat(fulfillmentFeePerUnit) : null }),
        ...(storageFeePerUnit !== undefined && { storageFeePerUnit: storageFeePerUnit ? parseFloat(storageFeePerUnit) : null }),
        ...(additionalFees !== undefined && { additionalFees }),
        ...(isActive !== undefined && { isActive })
      }
    });
    res.json(channel);
  } catch (error) {
    console.error('Update channel error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Channel code already exists' });
    }
    res.status(500).json({ error: 'Failed to update channel' });
  }
});

// DELETE channel
app.delete('/api/channels/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.salesChannel.findUnique({
      where: { id: req.params.id },
      include: { _count: { select: { channelPrices: true } } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Channel not found' });
    }
    if (existing._count.channelPrices > 0) {
      return res.status(400).json({ error: 'Cannot delete channel with prices configured' });
    }

    await prisma.salesChannel.delete({ where: { id: req.params.id } });
    res.json({ message: 'Channel deleted successfully' });
  } catch (error) {
    console.error('Delete channel error:', error);
    res.status(500).json({ error: 'Failed to delete channel' });
  }
});

// ===================================
// SUPPLIERS - Full CRUD
// ===================================

// GET all suppliers
app.get('/api/suppliers', verifyToken, async (req, res) => {
  try {
    const suppliers = await prisma.supplier.findMany({
      where: { companyId: req.user.companyId },
      orderBy: { name: 'asc' }
    });
    res.json(suppliers);
  } catch (error) {
    console.error('Get suppliers error:', error);
    res.status(500).json({ error: 'Failed to get suppliers' });
  }
});

// GET single supplier
app.get('/api/suppliers/:id', verifyToken, async (req, res) => {
  try {
    const supplier = await prisma.supplier.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      }
    });
    if (!supplier) {
      return res.status(404).json({ error: 'Supplier not found' });
    }
    res.json(supplier);
  } catch (error) {
    console.error('Get supplier error:', error);
    res.status(500).json({ error: 'Failed to get supplier' });
  }
});

// CREATE supplier
app.post('/api/suppliers', verifyToken, async (req, res) => {
  try {
    const { name, code, email, phone, address } = req.body;

    if (!name || !code) {
      return res.status(400).json({ error: 'Name and code are required' });
    }

    const supplier = await prisma.supplier.create({
      data: {
        name,
        code,
        email,
        phone,
        address,
        companyId: req.user.companyId
      }
    });
    res.status(201).json(supplier);
  } catch (error) {
    console.error('Create supplier error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Supplier code already exists' });
    }
    res.status(500).json({ error: 'Failed to create supplier' });
  }
});

// UPDATE supplier
app.put('/api/suppliers/:id', verifyToken, async (req, res) => {
  try {
    const { name, code, email, phone, address } = req.body;

    const existing = await prisma.supplier.findFirst({
      where: { id: req.params.id, companyId: req.user.companyId }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Supplier not found' });
    }

    const supplier = await prisma.supplier.update({
      where: { id: req.params.id },
      data: {
        ...(name && { name }),
        ...(code && { code }),
        ...(email !== undefined && { email }),
        ...(phone !== undefined && { phone }),
        ...(address !== undefined && { address })
      }
    });
    res.json(supplier);
  } catch (error) {
    console.error('Update supplier error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Supplier code already exists' });
    }
    res.status(500).json({ error: 'Failed to update supplier' });
  }
});

// DELETE supplier
app.delete('/api/suppliers/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.supplier.findFirst({
      where: { id: req.params.id, companyId: req.user.companyId }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Supplier not found' });
    }

    await prisma.supplier.delete({ where: { id: req.params.id } });
    res.json({ message: 'Supplier deleted successfully' });
  } catch (error) {
    console.error('Delete supplier error:', error);
    res.status(500).json({ error: 'Failed to delete supplier' });
  }
});

// ===================================
// ORDERS - Full CRUD (alias for sales-orders)
// ===================================

// GET single order
app.get('/api/orders/:id', verifyToken, async (req, res) => {
  try {
    const order = await prisma.salesOrder.findFirst({
      where: { id: req.params.id },
      include: {
        customer: true,
        items: { include: { product: true } },
        pickLists: true
      }
    });
    if (!order) {
      return res.status(404).json({ error: 'Order not found' });
    }
    res.json(order);
  } catch (error) {
    console.error('Get order error:', error);
    res.status(500).json({ error: 'Failed to get order' });
  }
});

// CREATE order
app.post('/api/orders', verifyToken, async (req, res) => {
  try {
    const { customerId, isWholesale, salesChannel, items, shippingAddress, shippingMethod, notes, priority } = req.body;

    if (!customerId || !items || items.length === 0) {
      return res.status(400).json({ error: 'Customer ID and items are required' });
    }

    // Generate order number
    const orderCount = await prisma.salesOrder.count();
    const orderNumber = `SO-${String(orderCount + 1).padStart(6, '0')}`;

    // Calculate totals
    let subtotal = 0;
    const orderItems = [];
    for (const item of items) {
      const product = await prisma.product.findUnique({ where: { id: item.productId } });
      if (!product) {
        return res.status(400).json({ error: `Product not found: ${item.productId}` });
      }
      const unitPrice = item.unitPrice || product.sellingPrice || 0;
      const totalPrice = unitPrice * item.quantity;
      subtotal += totalPrice;
      orderItems.push({
        productId: item.productId,
        quantity: item.quantity,
        unitPrice,
        discount: item.discount || 0,
        tax: item.tax || 0,
        totalPrice
      });
    }

    const order = await prisma.salesOrder.create({
      data: {
        orderNumber,
        customerId,
        isWholesale: isWholesale || false,
        salesChannel,
        status: 'PENDING',
        priority: priority || 'MEDIUM',
        shippingAddress,
        shippingMethod,
        notes,
        subtotal,
        totalAmount: subtotal,
        items: {
          create: orderItems
        }
      },
      include: {
        customer: true,
        items: { include: { product: true } }
      }
    });
    res.status(201).json(order);
  } catch (error) {
    console.error('Create order error:', error);
    res.status(500).json({ error: 'Failed to create order' });
  }
});

// UPDATE order
app.put('/api/orders/:id', verifyToken, async (req, res) => {
  try {
    const { status, priority, isWholesale, shippingAddress, shippingMethod, notes, trackingNumber } = req.body;

    const existing = await prisma.salesOrder.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Order not found' });
    }

    const order = await prisma.salesOrder.update({
      where: { id: req.params.id },
      data: {
        ...(status && { status }),
        ...(priority && { priority }),
        ...(isWholesale !== undefined && { isWholesale }),
        ...(shippingAddress !== undefined && { shippingAddress }),
        ...(shippingMethod !== undefined && { shippingMethod }),
        ...(notes !== undefined && { notes }),
        ...(trackingNumber !== undefined && { trackingNumber }),
        ...(status === 'SHIPPED' && { shippedDate: new Date() })
      },
      include: {
        customer: true,
        items: { include: { product: true } }
      }
    });
    res.json(order);
  } catch (error) {
    console.error('Update order error:', error);
    res.status(500).json({ error: 'Failed to update order' });
  }
});

// DELETE order
app.delete('/api/orders/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.salesOrder.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Order not found' });
    }
    if (!['PENDING', 'CANCELLED'].includes(existing.status)) {
      return res.status(400).json({ error: 'Can only delete pending or cancelled orders' });
    }

    await prisma.salesOrderItem.deleteMany({ where: { orderId: req.params.id } });
    await prisma.salesOrder.delete({ where: { id: req.params.id } });
    res.json({ message: 'Order deleted successfully' });
  } catch (error) {
    console.error('Delete order error:', error);
    res.status(500).json({ error: 'Failed to delete order' });
  }
});

// ===================================
// ZONES - Full CRUD
// ===================================

// GET all zones
app.get('/api/zones', verifyToken, async (req, res) => {
  try {
    const { warehouseId } = req.query;
    const zones = await prisma.zone.findMany({
      where: warehouseId ? {
        warehouse: { companyId: req.user.companyId },
        warehouseId
      } : {
        warehouse: { companyId: req.user.companyId }
      },
      include: {
        warehouse: true,
        _count: { select: { locations: true } }
      },
      orderBy: { name: 'asc' }
    });
    res.json(zones);
  } catch (error) {
    console.error('Get zones error:', error);
    res.status(500).json({ error: 'Failed to get zones' });
  }
});

// GET single zone
app.get('/api/zones/:id', verifyToken, async (req, res) => {
  try {
    const zone = await prisma.zone.findFirst({
      where: {
        id: req.params.id,
        warehouse: { companyId: req.user.companyId }
      },
      include: {
        warehouse: true,
        locations: true,
        _count: { select: { locations: true } }
      }
    });
    if (!zone) {
      return res.status(404).json({ error: 'Zone not found' });
    }
    res.json(zone);
  } catch (error) {
    console.error('Get zone error:', error);
    res.status(500).json({ error: 'Failed to get zone' });
  }
});

// CREATE zone
app.post('/api/zones', verifyToken, async (req, res) => {
  try {
    const { name, code, warehouseId, zoneType } = req.body;

    if (!name || !code || !warehouseId) {
      return res.status(400).json({ error: 'Name, code, and warehouseId are required' });
    }

    // Verify warehouse belongs to company
    const warehouse = await prisma.warehouse.findFirst({
      where: { id: warehouseId, companyId: req.user.companyId }
    });
    if (!warehouse) {
      return res.status(400).json({ error: 'Warehouse not found' });
    }

    const zone = await prisma.zone.create({
      data: {
        name,
        code,
        warehouseId,
        zoneType: zoneType || 'STANDARD'
      },
      include: { warehouse: true }
    });
    res.status(201).json(zone);
  } catch (error) {
    console.error('Create zone error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Zone code already exists in this warehouse' });
    }
    res.status(500).json({ error: 'Failed to create zone' });
  }
});

// UPDATE zone
app.put('/api/zones/:id', verifyToken, async (req, res) => {
  try {
    const { name, code, zoneType } = req.body;

    const existing = await prisma.zone.findFirst({
      where: { id: req.params.id, warehouse: { companyId: req.user.companyId } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Zone not found' });
    }

    const zone = await prisma.zone.update({
      where: { id: req.params.id },
      data: {
        ...(name && { name }),
        ...(code && { code }),
        ...(zoneType && { zoneType })
      },
      include: { warehouse: true }
    });
    res.json(zone);
  } catch (error) {
    console.error('Update zone error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Zone code already exists in this warehouse' });
    }
    res.status(500).json({ error: 'Failed to update zone' });
  }
});

// DELETE zone
app.delete('/api/zones/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.zone.findFirst({
      where: { id: req.params.id, warehouse: { companyId: req.user.companyId } },
      include: { _count: { select: { locations: true } } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Zone not found' });
    }
    if (existing._count.locations > 0) {
      return res.status(400).json({ error: 'Cannot delete zone with locations' });
    }

    await prisma.zone.delete({ where: { id: req.params.id } });
    res.json({ message: 'Zone deleted successfully' });
  } catch (error) {
    console.error('Delete zone error:', error);
    res.status(500).json({ error: 'Failed to delete zone' });
  }
});

// ===================================
// PICK LISTS - Full CRUD
// ===================================

// GET single pick list
app.get('/api/pick-lists/:id', verifyToken, async (req, res) => {
  try {
    const pickList = await prisma.pickList.findUnique({
      where: { id: req.params.id },
      include: {
        order: { include: { customer: true } },
        assignedUser: true,
        items: {
          include: {
            product: true,
            location: true
          }
        }
      }
    });
    if (!pickList) {
      return res.status(404).json({ error: 'Pick list not found' });
    }
    res.json(pickList);
  } catch (error) {
    console.error('Get pick list error:', error);
    res.status(500).json({ error: 'Failed to get pick list' });
  }
});

// UPDATE pick list
app.put('/api/pick-lists/:id', verifyToken, async (req, res) => {
  try {
    const { status, assignedUserId, priority, enforceSingleBBDate } = req.body;

    const existing = await prisma.pickList.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Pick list not found' });
    }

    const pickList = await prisma.pickList.update({
      where: { id: req.params.id },
      data: {
        ...(status && { status }),
        ...(assignedUserId !== undefined && { assignedUserId }),
        ...(priority && { priority }),
        ...(enforceSingleBBDate !== undefined && { enforceSingleBBDate }),
        ...(status === 'IN_PROGRESS' && !existing.startedAt && { startedAt: new Date() }),
        ...(status === 'COMPLETED' && { completedAt: new Date() })
      },
      include: {
        order: { include: { customer: true } },
        assignedUser: true,
        items: { include: { product: true, location: true } }
      }
    });
    res.json(pickList);
  } catch (error) {
    console.error('Update pick list error:', error);
    res.status(500).json({ error: 'Failed to update pick list' });
  }
});

// DELETE pick list
app.delete('/api/pick-lists/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.pickList.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Pick list not found' });
    }
    if (!['PENDING', 'CANCELLED'].includes(existing.status)) {
      return res.status(400).json({ error: 'Can only delete pending or cancelled pick lists' });
    }

    await prisma.pickItem.deleteMany({ where: { pickListId: req.params.id } });
    await prisma.pickList.delete({ where: { id: req.params.id } });
    res.json({ message: 'Pick list deleted successfully' });
  } catch (error) {
    console.error('Delete pick list error:', error);
    res.status(500).json({ error: 'Failed to delete pick list' });
  }
});

// ===================================
// REPLENISHMENT TASKS - Full CRUD
// ===================================

// GET single replenishment task
app.get('/api/replenishment/tasks/:id', verifyToken, async (req, res) => {
  try {
    const task = await prisma.replenishmentTask.findUnique({
      where: { id: req.params.id },
      include: { product: true }
    });
    if (!task) {
      return res.status(404).json({ error: 'Replenishment task not found' });
    }
    res.json(task);
  } catch (error) {
    console.error('Get replenishment task error:', error);
    res.status(500).json({ error: 'Failed to get replenishment task' });
  }
});

// CREATE replenishment task
app.post('/api/replenishment/tasks', verifyToken, async (req, res) => {
  try {
    const { productId, fromLocation, toLocation, quantityNeeded, priority, notes } = req.body;

    if (!productId || !quantityNeeded) {
      return res.status(400).json({ error: 'Product ID and quantity needed are required' });
    }

    const taskCount = await prisma.replenishmentTask.count();
    const taskNumber = `RPL-${String(taskCount + 1).padStart(6, '0')}`;

    const task = await prisma.replenishmentTask.create({
      data: {
        taskNumber,
        productId,
        fromLocation,
        toLocation,
        quantityNeeded,
        priority: priority || 'MEDIUM',
        notes,
        status: 'PENDING'
      },
      include: { product: true }
    });
    res.status(201).json(task);
  } catch (error) {
    console.error('Create replenishment task error:', error);
    res.status(500).json({ error: 'Failed to create replenishment task' });
  }
});

// UPDATE replenishment task
app.put('/api/replenishment/tasks/:id', verifyToken, async (req, res) => {
  try {
    const { status, quantityMoved, assignedUserId, notes, priority } = req.body;

    const existing = await prisma.replenishmentTask.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Replenishment task not found' });
    }

    const task = await prisma.replenishmentTask.update({
      where: { id: req.params.id },
      data: {
        ...(status && { status }),
        ...(quantityMoved !== undefined && { quantityMoved }),
        ...(assignedUserId !== undefined && { assignedUserId }),
        ...(notes !== undefined && { notes }),
        ...(priority && { priority }),
        ...(status === 'COMPLETED' && { completedAt: new Date() })
      },
      include: { product: true }
    });
    res.json(task);
  } catch (error) {
    console.error('Update replenishment task error:', error);
    res.status(500).json({ error: 'Failed to update replenishment task' });
  }
});

// DELETE replenishment task
app.delete('/api/replenishment/tasks/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.replenishmentTask.findUnique({ where: { id: req.params.id } });
    if (!existing) {
      return res.status(404).json({ error: 'Replenishment task not found' });
    }
    if (!['PENDING', 'CANCELLED'].includes(existing.status)) {
      return res.status(400).json({ error: 'Can only delete pending or cancelled tasks' });
    }

    await prisma.replenishmentTask.delete({ where: { id: req.params.id } });
    res.json({ message: 'Replenishment task deleted successfully' });
  } catch (error) {
    console.error('Delete replenishment task error:', error);
    res.status(500).json({ error: 'Failed to delete replenishment task' });
  }
});

// ===================================
// CYCLE COUNTS - Full CRUD
// ===================================

// GET single cycle count
app.get('/api/inventory/cycle-counts/:id', verifyToken, async (req, res) => {
  try {
    const cycleCount = await prisma.cycleCount.findFirst({
      where: {
        id: req.params.id,
        warehouse: { companyId: req.user.companyId }
      },
      include: {
        warehouse: true,
        items: { include: { product: true } }
      }
    });
    if (!cycleCount) {
      return res.status(404).json({ error: 'Cycle count not found' });
    }
    res.json(cycleCount);
  } catch (error) {
    console.error('Get cycle count error:', error);
    res.status(500).json({ error: 'Failed to get cycle count' });
  }
});

// UPDATE cycle count
app.put('/api/inventory/cycle-counts/:id', verifyToken, async (req, res) => {
  try {
    const { status, name, scheduledDate, type, locations, variance } = req.body;

    const existing = await prisma.cycleCount.findFirst({
      where: { id: req.params.id, warehouse: { companyId: req.user.companyId } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Cycle count not found' });
    }

    const cycleCount = await prisma.cycleCount.update({
      where: { id: req.params.id },
      data: {
        ...(status && { status }),
        ...(name && { name }),
        ...(scheduledDate && { scheduledDate: new Date(scheduledDate) }),
        ...(type && { type }),
        ...(locations !== undefined && { locations }),
        ...(variance !== undefined && { variance }),
        ...(status === 'COMPLETED' && { completedDate: new Date() })
      },
      include: {
        warehouse: true,
        items: { include: { product: true } }
      }
    });
    res.json(cycleCount);
  } catch (error) {
    console.error('Update cycle count error:', error);
    res.status(500).json({ error: 'Failed to update cycle count' });
  }
});

// DELETE cycle count
app.delete('/api/inventory/cycle-counts/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.cycleCount.findFirst({
      where: { id: req.params.id, warehouse: { companyId: req.user.companyId } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Cycle count not found' });
    }
    if (!['SCHEDULED', 'CANCELLED'].includes(existing.status)) {
      return res.status(400).json({ error: 'Can only delete scheduled or cancelled cycle counts' });
    }

    await prisma.cycleCountItem.deleteMany({ where: { cycleCountId: req.params.id } });
    await prisma.cycleCount.delete({ where: { id: req.params.id } });
    res.json({ message: 'Cycle count deleted successfully' });
  } catch (error) {
    console.error('Delete cycle count error:', error);
    res.status(500).json({ error: 'Failed to delete cycle count' });
  }
});

// ===================================
// STOCK ADJUSTMENTS - Full CRUD
// ===================================

// GET single stock adjustment
app.get('/api/inventory/adjustments/:id', verifyToken, async (req, res) => {
  try {
    const adjustment = await prisma.stockAdjustment.findFirst({
      where: {
        id: req.params.id,
        warehouse: { companyId: req.user.companyId }
      },
      include: {
        warehouse: true,
        user: true,
        approver: true,
        items: { include: { product: true, location: true } }
      }
    });
    if (!adjustment) {
      return res.status(404).json({ error: 'Adjustment not found' });
    }
    res.json(adjustment);
  } catch (error) {
    console.error('Get adjustment error:', error);
    res.status(500).json({ error: 'Failed to get adjustment' });
  }
});

// UPDATE stock adjustment
app.put('/api/inventory/adjustments/:id', verifyToken, async (req, res) => {
  try {
    const { status, notes } = req.body;

    const existing = await prisma.stockAdjustment.findFirst({
      where: { id: req.params.id, warehouse: { companyId: req.user.companyId } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Adjustment not found' });
    }

    const adjustment = await prisma.stockAdjustment.update({
      where: { id: req.params.id },
      data: {
        ...(status && { status }),
        ...(notes !== undefined && { notes }),
        ...(status === 'APPROVED' && { approvedBy: req.user.id }),
        ...(status === 'COMPLETED' && { completedAt: new Date() })
      },
      include: {
        warehouse: true,
        user: true,
        approver: true,
        items: { include: { product: true, location: true } }
      }
    });
    res.json(adjustment);
  } catch (error) {
    console.error('Update adjustment error:', error);
    res.status(500).json({ error: 'Failed to update adjustment' });
  }
});

// DELETE stock adjustment
app.delete('/api/inventory/adjustments/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.stockAdjustment.findFirst({
      where: { id: req.params.id, warehouse: { companyId: req.user.companyId } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Adjustment not found' });
    }
    if (!['PENDING', 'REJECTED'].includes(existing.status)) {
      return res.status(400).json({ error: 'Can only delete pending or rejected adjustments' });
    }

    await prisma.stockAdjustmentItem.deleteMany({ where: { adjustmentId: req.params.id } });
    await prisma.stockAdjustment.delete({ where: { id: req.params.id } });
    res.json({ message: 'Adjustment deleted successfully' });
  } catch (error) {
    console.error('Delete adjustment error:', error);
    res.status(500).json({ error: 'Failed to delete adjustment' });
  }
});

// ===================================
// BATCHES - Full CRUD (Update & Delete)
// ===================================

// UPDATE batch
app.put('/api/inventory/batches/:id', verifyToken, async (req, res) => {
  try {
    const { lotNumber, batchNumber, bestBeforeDate, quantity, availableQuantity, reservedQuantity, status } = req.body;

    const existing = await prisma.inventory.findFirst({
      where: { id: req.params.id, warehouse: { companyId: req.user.companyId } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Batch not found' });
    }

    const batch = await prisma.inventory.update({
      where: { id: req.params.id },
      data: {
        ...(lotNumber !== undefined && { lotNumber }),
        ...(batchNumber !== undefined && { batchNumber }),
        ...(bestBeforeDate !== undefined && { bestBeforeDate: bestBeforeDate ? new Date(bestBeforeDate) : null }),
        ...(quantity !== undefined && { quantity }),
        ...(availableQuantity !== undefined && { availableQuantity }),
        ...(reservedQuantity !== undefined && { reservedQuantity }),
        ...(status && { status })
      },
      include: {
        product: true,
        warehouse: true,
        location: true
      }
    });
    res.json(batch);
  } catch (error) {
    console.error('Update batch error:', error);
    res.status(500).json({ error: 'Failed to update batch' });
  }
});

// DELETE batch
app.delete('/api/inventory/batches/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.inventory.findFirst({
      where: { id: req.params.id, warehouse: { companyId: req.user.companyId } }
    });
    if (!existing) {
      return res.status(404).json({ error: 'Batch not found' });
    }
    if (existing.reservedQuantity > 0) {
      return res.status(400).json({ error: 'Cannot delete batch with reserved quantity' });
    }

    await prisma.inventory.delete({ where: { id: req.params.id } });
    res.json({ message: 'Batch deleted successfully' });
  } catch (error) {
    console.error('Delete batch error:', error);
    res.status(500).json({ error: 'Failed to delete batch' });
  }
});

// ===================================
// MARKETPLACE INTEGRATIONS API
// ===================================

const IntegrationClientFactory = require('./lib/integrations/clientFactory');
const encryptionService = require('./lib/encryption');
const JobQueueProcessor = require('./lib/queue');

// GET all integrations for company
app.get('/api/integrations', verifyToken, async (req, res) => {
  try {
    const integrations = await prisma.integration.findMany({
      where: { companyId: req.user.companyId },
      include: {
        _count: {
          select: {
            mappings: true,
            syncLogs: true,
            orderImports: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    // Don't send raw credentials back to frontend
    const sanitized = integrations.map(int => ({
      ...int,
      credentials: '***ENCRYPTED***',
      _count: int._count
    }));

    res.json(sanitized);
  } catch (error) {
    console.error('Get integrations error:', error);
    res.status(500).json({ error: 'Failed to fetch integrations' });
  }
});

// GET single integration by ID
app.get('/api/integrations/:id', verifyToken, async (req, res) => {
  try {
    const integration = await prisma.integration.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      },
      include: {
        mappings: {
          include: { integration: true },
          take: 100
        },
        syncLogs: {
          orderBy: { createdAt: 'desc' },
          take: 20
        },
        _count: {
          select: {
            mappings: true,
            orderImports: true
          }
        }
      }
    });

    if (!integration) {
      return res.status(404).json({ error: 'Integration not found' });
    }

    // Don't send raw credentials
    const sanitized = {
      ...integration,
      credentials: '***ENCRYPTED***'
    };

    res.json(sanitized);
  } catch (error) {
    console.error('Get integration error:', error);
    res.status(500).json({ error: 'Failed to fetch integration' });
  }
});

// POST create new integration
app.post('/api/integrations', verifyToken, async (req, res) => {
  try {
    const { platform, credentials, syncFrequency } = req.body;

    if (!platform || !credentials) {
      return res.status(400).json({ error: 'Platform and credentials are required' });
    }

    // Validate credentials for platform
    const validation = IntegrationClientFactory.validateCredentials(platform, credentials);
    if (!validation.valid) {
      return res.status(400).json({ error: validation.errors.join(', ') });
    }

    // Encrypt credentials before storing
    const credentialsJson = JSON.stringify(credentials);
    const encrypted = encryptionService.encrypt(credentialsJson);
    const encryptedStr = JSON.stringify(encrypted);

    // Create integration record
    const integration = await prisma.integration.create({
      data: {
        companyId: req.user.companyId,
        platform,
        credentials: encryptedStr,
        isActive: true,
        syncFrequency: syncFrequency || 'HOURLY'
      }
    });

    // Test connection
    const testResult = await IntegrationClientFactory.testConnection(integration);

    if (!testResult.success) {
      // Delete integration if connection test fails
      await prisma.integration.delete({ where: { id: integration.id } });
      return res.status(400).json({
        error: 'Connection test failed',
        details: testResult.message
      });
    }

    res.status(201).json({
      ...integration,
      credentials: '***ENCRYPTED***',
      testResult
    });
  } catch (error) {
    console.error('Create integration error:', error);
    res.status(500).json({ error: error.message || 'Failed to create integration' });
  }
});

// PUT update integration
app.put('/api/integrations/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.integration.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      }
    });

    if (!existing) {
      return res.status(404).json({ error: 'Integration not found' });
    }

    const { credentials, isActive, syncFrequency } = req.body;
    const updateData = {};

    if (credentials) {
      // Validate and encrypt new credentials
      const validation = IntegrationClientFactory.validateCredentials(existing.platform, credentials);
      if (!validation.valid) {
        return res.status(400).json({ error: validation.errors.join(', ') });
      }

      const credentialsJson = JSON.stringify(credentials);
      const encrypted = encryptionService.encrypt(credentialsJson);
      updateData.credentials = JSON.stringify(encrypted);
    }

    if (typeof isActive !== 'undefined') {
      updateData.isActive = isActive;
    }

    if (syncFrequency) {
      updateData.syncFrequency = syncFrequency;
    }

    const updated = await prisma.integration.update({
      where: { id: req.params.id },
      data: updateData
    });

    res.json({
      ...updated,
      credentials: '***ENCRYPTED***'
    });
  } catch (error) {
    console.error('Update integration error:', error);
    res.status(500).json({ error: 'Failed to update integration' });
  }
});

// DELETE integration
app.delete('/api/integrations/:id', verifyToken, async (req, res) => {
  try {
    const existing = await prisma.integration.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      }
    });

    if (!existing) {
      return res.status(404).json({ error: 'Integration not found' });
    }

    // Delete will cascade to mappings, sync logs, order imports
    await prisma.integration.delete({ where: { id: req.params.id } });

    res.json({ message: 'Integration deleted successfully' });
  } catch (error) {
    console.error('Delete integration error:', error);
    res.status(500).json({ error: 'Failed to delete integration' });
  }
});

// POST manual sync trigger
app.post('/api/integrations/:id/sync', verifyToken, async (req, res) => {
  try {
    const { syncType } = req.body; // 'ORDERS' or 'INVENTORY'

    const integration = await prisma.integration.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      }
    });

    if (!integration) {
      return res.status(404).json({ error: 'Integration not found' });
    }

    if (!integration.isActive) {
      return res.status(400).json({ error: 'Integration is not active' });
    }

    // Create job in queue
    const job = await prisma.jobQueue.create({
      data: {
        type: syncType === 'INVENTORY' ? 'SYNC_INVENTORY' : 'SYNC_ORDERS',
        payload: JSON.stringify({
          integrationId: integration.id,
          triggeredBy: req.user.id
        }),
        status: 'PENDING',
        processAt: new Date()
      }
    });

    // Process job immediately (in production, this would be handled by background worker)
    const processor = new JobQueueProcessor();
    processor.processNextJob();

    res.json({
      message: 'Sync started',
      jobId: job.id,
      type: syncType
    });
  } catch (error) {
    console.error('Manual sync error:', error);
    res.status(500).json({ error: 'Failed to start sync' });
  }
});

// GET sync logs for integration
app.get('/api/integrations/:id/logs', verifyToken, async (req, res) => {
  try {
    const { limit = 50, offset = 0, syncType } = req.query;

    const where = {
      integrationId: req.params.id,
      integration: { companyId: req.user.companyId }
    };

    if (syncType) {
      where.syncType = syncType;
    }

    const logs = await prisma.syncLog.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      take: parseInt(limit),
      skip: parseInt(offset)
    });

    const total = await prisma.syncLog.count({ where });

    res.json({
      logs,
      total,
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (error) {
    console.error('Get sync logs error:', error);
    res.status(500).json({ error: 'Failed to fetch sync logs' });
  }
});

// GET integration mappings (SKU mappings)
app.get('/api/integrations/:id/mappings', verifyToken, async (req, res) => {
  try {
    const mappings = await prisma.integrationMapping.findMany({
      where: {
        integrationId: req.params.id,
        integration: { companyId: req.user.companyId }
      },
      orderBy: { createdAt: 'desc' }
    });

    res.json(mappings);
  } catch (error) {
    console.error('Get mappings error:', error);
    res.status(500).json({ error: 'Failed to fetch mappings' });
  }
});

// POST create SKU mapping
app.post('/api/integrations/:id/mappings', verifyToken, async (req, res) => {
  try {
    const { internalSku, externalSku, externalProductId } = req.body;

    if (!internalSku || !externalSku) {
      return res.status(400).json({ error: 'Internal and external SKU are required' });
    }

    const integration = await prisma.integration.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      }
    });

    if (!integration) {
      return res.status(404).json({ error: 'Integration not found' });
    }

    // Check if internal SKU exists
    const product = await prisma.product.findFirst({
      where: { sku: internalSku }
    });

    if (!product) {
      return res.status(400).json({ error: 'Internal SKU not found in products' });
    }

    const mapping = await prisma.integrationMapping.create({
      data: {
        integrationId: req.params.id,
        internalSku,
        externalSku,
        externalProductId
      }
    });

    res.status(201).json(mapping);
  } catch (error) {
    console.error('Create mapping error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Mapping already exists' });
    }
    res.status(500).json({ error: 'Failed to create mapping' });
  }
});

// DELETE mapping
app.delete('/api/integrations/:integrationId/mappings/:mappingId', verifyToken, async (req, res) => {
  try {
    const mapping = await prisma.integrationMapping.findFirst({
      where: {
        id: req.params.mappingId,
        integrationId: req.params.integrationId,
        integration: { companyId: req.user.companyId }
      }
    });

    if (!mapping) {
      return res.status(404).json({ error: 'Mapping not found' });
    }

    await prisma.integrationMapping.delete({
      where: { id: req.params.mappingId }
    });

    res.json({ message: 'Mapping deleted successfully' });
  } catch (error) {
    console.error('Delete mapping error:', error);
    res.status(500).json({ error: 'Failed to delete mapping' });
  }
});

// GET supported platforms
app.get('/api/integrations/platforms/supported', verifyToken, async (req, res) => {
  try {
    const platforms = IntegrationClientFactory.getSupportedPlatforms();
    res.json(platforms);
  } catch (error) {
    console.error('Get supported platforms error:', error);
    res.status(500).json({ error: 'Failed to fetch supported platforms' });
  }
});

// POST test connection
app.post('/api/integrations/:id/test-connection', verifyToken, async (req, res) => {
  try {
    const integration = await prisma.integration.findFirst({
      where: {
        id: req.params.id,
        companyId: req.user.companyId
      }
    });

    if (!integration) {
      return res.status(404).json({ error: 'Integration not found' });
    }

    const result = await IntegrationClientFactory.testConnection(integration);
    res.json(result);
  } catch (error) {
    console.error('Test connection error:', error);
    res.status(500).json({ error: 'Failed to test connection' });
  }
});

// ===================================
// WEBHOOK RECEIVERS
// ===================================

// Shopify webhook receiver
app.post('/api/webhooks/shopify', async (req, res) => {
  try {
    const topic = req.headers['x-shopify-topic'];
    const shop = req.headers['x-shopify-shop-domain'];

    // Find integration by shop domain
    const integration = await prisma.integration.findFirst({
      where: {
        platform: 'SHOPIFY',
        isActive: true
      }
    });

    if (!integration) {
      console.warn(`No active Shopify integration found for shop: ${shop}`);
      return res.status(404).json({ error: 'Integration not found' });
    }

    // Create client and handle webhook
    const client = IntegrationClientFactory.createClient(integration);
    await client.handleWebhook(topic, req.body);

    res.status(200).json({ message: 'Webhook processed' });
  } catch (error) {
    console.error('Shopify webhook error:', error);
    res.status(500).json({ error: 'Failed to process webhook' });
  }
});

// TikTok Shop webhook receiver
app.post('/api/webhooks/tiktok', async (req, res) => {
  try {
    const { type, shop_id, data } = req.body;

    // Find integration by shop_id
    const integration = await prisma.integration.findFirst({
      where: {
        platform: 'TIKTOK',
        isActive: true
      }
    });

    if (!integration) {
      return res.status(404).json({ error: 'Integration not found' });
    }

    // Handle webhook based on type
    if (type === 'ORDER_STATUS_CHANGE' || type === 'NEW_ORDER') {
      const client = IntegrationClientFactory.createClient(integration);
      const orderDetail = await client.makeRequest('/api/orders/detail/query', 'POST', {
        shop_id,
        order_id_list: [data.order_id]
      });

      if (orderDetail.order_list?.[0]) {
        await client.importOrder(orderDetail.order_list[0]);
      }
    }

    res.status(200).json({ message: 'Webhook processed' });
  } catch (error) {
    console.error('TikTok webhook error:', error);
    res.status(500).json({ error: 'Failed to process webhook' });
  }
});

// =============================================================================
// PHASE 5: SHIPPING INTEGRATIONS API
// =============================================================================

const ShippingCarrierFactory = require('./lib/shipping/carrierFactory');

// Get supported shipping carriers (metadata)
app.get('/api/shipping/carriers/supported', async (req, res) => {
  try {
    const carriers = ShippingCarrierFactory.getSupportedCarriers();
    res.json(carriers);
  } catch (error) {
    console.error('Failed to get supported carriers:', error);
    res.status(500).json({ error: 'Failed to get supported carriers' });
  }
});

// List configured shipping carriers
app.get('/api/shipping/carriers', async (req, res) => {
  try {
    const { companyId } = req.user;

    const carriers = await prisma.shippingCarrier.findMany({
      where: { companyId },
      select: {
        id: true,
        name: true,
        carrierCode: true,
        country: true,
        isActive: true,
        isDefault: true,
        createdAt: true,
        updatedAt: true
      },
      orderBy: { createdAt: 'desc' }
    });

    res.json(carriers);
  } catch (error) {
    console.error('Failed to list carriers:', error);
    res.status(500).json({ error: 'Failed to list carriers' });
  }
});

// Get single carrier details
app.get('/api/shipping/carriers/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { companyId } = req.user;

    const carrier = await prisma.shippingCarrier.findFirst({
      where: { id, companyId },
      select: {
        id: true,
        name: true,
        carrierCode: true,
        country: true,
        isActive: true,
        isDefault: true,
        createdAt: true,
        updatedAt: true
      }
    });

    if (!carrier) {
      return res.status(404).json({ error: 'Carrier not found' });
    }

    // Get carrier metadata
    const metadata = ShippingCarrierFactory.getSupportedCarriers().find(
      c => c.carrierCode === carrier.carrierCode
    );

    res.json({ ...carrier, metadata });
  } catch (error) {
    console.error('Failed to get carrier:', error);
    res.status(500).json({ error: 'Failed to get carrier' });
  }
});

// Create new shipping carrier
app.post('/api/shipping/carriers', async (req, res) => {
  try {
    const { companyId } = req.user;
    const { name, carrierCode, credentials, isDefault = false } = req.body;

    // Validate credentials
    const validation = ShippingCarrierFactory.validateCredentials(carrierCode, credentials);
    if (!validation.valid) {
      return res.status(400).json({
        error: 'Invalid credentials',
        details: validation.errors
      });
    }

    // Encrypt credentials
    const encryptedCredentials = encryptionService.encrypt(JSON.stringify(credentials));

    // Get carrier metadata
    const carrierConfig = ShippingCarrierFactory.getSupportedCarriers().find(
      c => c.carrierCode === carrierCode
    );

    if (!carrierConfig) {
      return res.status(400).json({ error: 'Unsupported carrier' });
    }

    // If setting as default, unset other defaults
    if (isDefault) {
      await prisma.shippingCarrier.updateMany({
        where: { companyId, isDefault: true },
        data: { isDefault: false }
      });
    }

    // Create carrier
    const carrier = await prisma.shippingCarrier.create({
      data: {
        companyId,
        name: name || carrierConfig.name,
        carrierCode,
        country: carrierConfig.country,
        credentials: JSON.stringify(encryptedCredentials),
        isActive: false, // Start inactive until connection test passes
        isDefault
      }
    });

    // Test connection
    try {
      const testResult = await ShippingCarrierFactory.testConnection(carrier);

      if (testResult.success) {
        // Activate carrier if test passes
        await prisma.shippingCarrier.update({
          where: { id: carrier.id },
          data: { isActive: true }
        });

        res.status(201).json({
          ...carrier,
          credentials: undefined, // Don't return credentials
          connectionTest: testResult
        });
      } else {
        res.status(201).json({
          ...carrier,
          credentials: undefined,
          connectionTest: testResult,
          warning: 'Carrier created but connection test failed. Please verify credentials.'
        });
      }
    } catch (testError) {
      console.error('Connection test failed:', testError);
      res.status(201).json({
        ...carrier,
        credentials: undefined,
        connectionTest: { success: false, message: testError.message },
        warning: 'Carrier created but connection test failed.'
      });
    }
  } catch (error) {
    console.error('Failed to create carrier:', error);
    res.status(500).json({ error: 'Failed to create carrier' });
  }
});

// Update carrier
app.put('/api/shipping/carriers/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { companyId } = req.user;
    const { name, credentials, isActive, isDefault } = req.body;

    const carrier = await prisma.shippingCarrier.findFirst({
      where: { id, companyId }
    });

    if (!carrier) {
      return res.status(404).json({ error: 'Carrier not found' });
    }

    const updateData = {};

    if (name !== undefined) updateData.name = name;
    if (isActive !== undefined) updateData.isActive = isActive;

    if (credentials) {
      // Validate new credentials
      const validation = ShippingCarrierFactory.validateCredentials(
        carrier.carrierCode,
        credentials
      );

      if (!validation.valid) {
        return res.status(400).json({
          error: 'Invalid credentials',
          details: validation.errors
        });
      }

      // Encrypt credentials
      const encryptedCredentials = encryptionService.encrypt(JSON.stringify(credentials));
      updateData.credentials = JSON.stringify(encryptedCredentials);
    }

    if (isDefault === true) {
      // Unset other defaults
      await prisma.shippingCarrier.updateMany({
        where: { companyId, isDefault: true, id: { not: id } },
        data: { isDefault: false }
      });
      updateData.isDefault = true;
    } else if (isDefault === false) {
      updateData.isDefault = false;
    }

    const updated = await prisma.shippingCarrier.update({
      where: { id },
      data: updateData
    });

    res.json({
      ...updated,
      credentials: undefined
    });
  } catch (error) {
    console.error('Failed to update carrier:', error);
    res.status(500).json({ error: 'Failed to update carrier' });
  }
});

// Delete carrier
app.delete('/api/shipping/carriers/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { companyId } = req.user;

    const carrier = await prisma.shippingCarrier.findFirst({
      where: { id, companyId }
    });

    if (!carrier) {
      return res.status(404).json({ error: 'Carrier not found' });
    }

    // Check for existing shipments
    const shipmentsCount = await prisma.shipment.count({
      where: { carrierId: id }
    });

    if (shipmentsCount > 0) {
      return res.status(400).json({
        error: 'Cannot delete carrier with existing shipments',
        shipmentsCount
      });
    }

    await prisma.shippingCarrier.delete({
      where: { id }
    });

    res.json({ message: 'Carrier deleted successfully' });
  } catch (error) {
    console.error('Failed to delete carrier:', error);
    res.status(500).json({ error: 'Failed to delete carrier' });
  }
});

// Test carrier connection
app.post('/api/shipping/carriers/:id/test', async (req, res) => {
  try {
    const { id } = req.params;
    const { companyId } = req.user;

    const carrier = await prisma.shippingCarrier.findFirst({
      where: { id, companyId }
    });

    if (!carrier) {
      return res.status(404).json({ error: 'Carrier not found' });
    }

    const result = await ShippingCarrierFactory.testConnection(carrier);
    res.json(result);
  } catch (error) {
    console.error('Connection test failed:', error);
    res.status(500).json({
      success: false,
      message: error.message
    });
  }
});

// Get available services for a carrier
app.get('/api/shipping/carriers/:id/services', async (req, res) => {
  try {
    const { id } = req.params;
    const { companyId } = req.user;

    const carrier = await prisma.shippingCarrier.findFirst({
      where: { id, companyId }
    });

    if (!carrier) {
      return res.status(404).json({ error: 'Carrier not found' });
    }

    const services = ShippingCarrierFactory.getCarrierServices(carrier.carrierCode);
    res.json(services);
  } catch (error) {
    console.error('Failed to get services:', error);
    res.status(500).json({ error: 'Failed to get services' });
  }
});

// Compare shipping rates across carriers
app.post('/api/shipping/compare-rates', async (req, res) => {
  try {
    const { companyId } = req.user;
    const { fromAddress, toAddress, parcelDetails, carrierCodes } = req.body;

    if (!fromAddress || !toAddress || !parcelDetails) {
      return res.status(400).json({
        error: 'Missing required fields: fromAddress, toAddress, parcelDetails'
      });
    }

    // Filter by company's carriers
    const whereClause = { companyId, isActive: true };
    if (carrierCodes && carrierCodes.length > 0) {
      whereClause.carrierCode = { in: carrierCodes };
    }

    const carriers = await prisma.shippingCarrier.findMany({
      where: whereClause
    });

    if (carriers.length === 0) {
      return res.status(404).json({ error: 'No active carriers found' });
    }

    const rates = [];

    for (const carrier of carriers) {
      try {
        const client = ShippingCarrierFactory.createClient(carrier);
        const services = await client.getServices(fromAddress, toAddress, parcelDetails);

        for (const service of services) {
          rates.push({
            carrier: {
              id: carrier.id,
              code: carrier.carrierCode,
              name: carrier.name
            },
            service: {
              code: service.serviceCode,
              name: service.serviceName,
              description: service.description
            },
            price: service.price,
            currency: service.currency,
            estimatedDeliveryDays: service.estimatedDeliveryDays,
            estimatedDeliveryDate: service.estimatedDeliveryDate,
            features: {
              tracked: service.tracked,
              signed: service.signed,
              compensation: service.compensation
            }
          });
        }
      } catch (error) {
        console.error(`Failed to get rates from ${carrier.carrierCode}:`, error.message);
        // Continue with other carriers
      }
    }

    // Sort by price (cheapest first)
    rates.sort((a, b) => (a.price || 999999) - (b.price || 999999));

    res.json({
      rates,
      fromAddress,
      toAddress,
      parcelDetails,
      comparedAt: new Date().toISOString()
    });
  } catch (error) {
    console.error('Failed to compare rates:', error);
    res.status(500).json({ error: 'Failed to compare rates' });
  }
});

// Create shipment
app.post('/api/shipping/shipments', async (req, res) => {
  try {
    const { companyId } = req.user;
    const { carrierId, orderId, serviceCode, ...orderDetails } = req.body;

    if (!carrierId || !orderId || !serviceCode) {
      return res.status(400).json({
        error: 'Missing required fields: carrierId, orderId, serviceCode'
      });
    }

    const carrier = await prisma.shippingCarrier.findFirst({
      where: { id: carrierId, companyId, isActive: true }
    });

    if (!carrier) {
      return res.status(404).json({ error: 'Carrier not found or inactive' });
    }

    // Create client and shipment
    const client = ShippingCarrierFactory.createClient(carrier);
    const result = await client.createShipment({
      orderId,
      serviceCode,
      ...orderDetails
    });

    res.status(201).json(result);
  } catch (error) {
    console.error('Failed to create shipment:', error);
    res.status(500).json({ error: error.message || 'Failed to create shipment' });
  }
});

// List shipments
app.get('/api/shipping/shipments', async (req, res) => {
  try {
    const { companyId } = req.user;
    const { orderId, status, carrierId, limit = 50, offset = 0 } = req.query;

    const where = {
      carrier: { companyId }
    };

    if (orderId) where.orderId = orderId;
    if (status) where.status = status;
    if (carrierId) where.carrierId = carrierId;

    const [shipments, total] = await Promise.all([
      prisma.shipment.findMany({
        where,
        include: {
          carrier: {
            select: {
              id: true,
              name: true,
              carrierCode: true
            }
          }
        },
        orderBy: { createdAt: 'desc' },
        take: parseInt(limit),
        skip: parseInt(offset)
      }),
      prisma.shipment.count({ where })
    ]);

    res.json({
      shipments,
      total,
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (error) {
    console.error('Failed to list shipments:', error);
    res.status(500).json({ error: 'Failed to list shipments' });
  }
});

// Get shipment details
app.get('/api/shipping/shipments/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const { companyId } = req.user;

    const shipment = await prisma.shipment.findFirst({
      where: {
        id,
        carrier: { companyId }
      },
      include: {
        carrier: {
          select: {
            id: true,
            name: true,
            carrierCode: true
          }
        }
      }
    });

    if (!shipment) {
      return res.status(404).json({ error: 'Shipment not found' });
    }

    res.json(shipment);
  } catch (error) {
    console.error('Failed to get shipment:', error);
    res.status(500).json({ error: 'Failed to get shipment' });
  }
});

// Track shipment
app.get('/api/shipping/shipments/:id/track', async (req, res) => {
  try {
    const { id } = req.params;
    const { companyId } = req.user;

    const shipment = await prisma.shipment.findFirst({
      where: {
        id,
        carrier: { companyId }
      },
      include: { carrier: true }
    });

    if (!shipment) {
      return res.status(404).json({ error: 'Shipment not found' });
    }

    const client = ShippingCarrierFactory.createClient(shipment.carrier);
    const trackingInfo = await client.trackShipment(shipment.trackingNumber);

    res.json(trackingInfo);
  } catch (error) {
    console.error('Failed to track shipment:', error);
    res.status(500).json({ error: error.message || 'Failed to track shipment' });
  }
});

// Cancel shipment
app.post('/api/shipping/shipments/:id/cancel', async (req, res) => {
  try {
    const { id } = req.params;
    const { companyId } = req.user;

    const shipment = await prisma.shipment.findFirst({
      where: {
        id,
        carrier: { companyId }
      },
      include: { carrier: true }
    });

    if (!shipment) {
      return res.status(404).json({ error: 'Shipment not found' });
    }

    if (shipment.status === 'CANCELLED') {
      return res.status(400).json({ error: 'Shipment already cancelled' });
    }

    if (['DELIVERED', 'RETURNED'].includes(shipment.status)) {
      return res.status(400).json({
        error: `Cannot cancel shipment with status: ${shipment.status}`
      });
    }

    const client = ShippingCarrierFactory.createClient(shipment.carrier);
    const result = await client.cancelShipment(shipment.carrierShipmentId);

    res.json(result);
  } catch (error) {
    console.error('Failed to cancel shipment:', error);
    res.status(500).json({ error: error.message || 'Failed to cancel shipment' });
  }
});

// Get/print shipping label
app.get('/api/shipping/shipments/:id/label', async (req, res) => {
  try {
    const { id } = req.params;
    const { companyId } = req.user;

    const shipment = await prisma.shipment.findFirst({
      where: {
        id,
        carrier: { companyId }
      },
      include: { carrier: true }
    });

    if (!shipment) {
      return res.status(404).json({ error: 'Shipment not found' });
    }

    const client = ShippingCarrierFactory.createClient(shipment.carrier);
    const label = await client.printLabel(id);

    res.json(label);
  } catch (error) {
    console.error('Failed to get label:', error);
    res.status(500).json({ error: error.message || 'Failed to get label' });
  }
});

// Get shipping logs
app.get('/api/shipping/logs', async (req, res) => {
  try {
    const { companyId } = req.user;
    const { carrierId, operation, status, limit = 100, offset = 0 } = req.query;

    const where = {
      carrier: { companyId }
    };

    if (carrierId) where.carrierId = carrierId;
    if (operation) where.operation = operation;
    if (status) where.status = status;

    const [logs, total] = await Promise.all([
      prisma.shippingLog.findMany({
        where,
        include: {
          carrier: {
            select: {
              id: true,
              name: true,
              carrierCode: true
            }
          }
        },
        orderBy: { timestamp: 'desc' },
        take: parseInt(limit),
        skip: parseInt(offset)
      }),
      prisma.shippingLog.count({ where })
    ]);

    res.json({
      logs,
      total,
      limit: parseInt(limit),
      offset: parseInt(offset)
    });
  } catch (error) {
    console.error('Failed to get shipping logs:', error);
    res.status(500).json({ error: 'Failed to get shipping logs' });
  }
});

// ===================================
// NEW FEATURES - Supplier Products, Alternative SKUs, Bundles
// ===================================

// Supplier Products Management
app.use('/api/supplier-products', verifyToken, supplierProductsRouter);

// Alternative SKU Management (Amazon _BB, _M, marketplace SKUs)
app.use('/api/alternative-skus', verifyToken, alternativeSKUsRouter);

// Bundle Management (cost calculation, stock by BBD)
app.use('/api/bundles', verifyToken, bundlesRouter);

// ===================================
// INVENTORY VIEWS BY BBD AND LOCATION
// ===================================

// Get inventory grouped by Best Before Date
app.get('/api/inventory/by-best-before-date', verifyToken, async (req, res) => {
  try {
    const { productId, warehouseId } = req.query;
    const where = {};
    if (productId) where.productId = productId;
    if (warehouseId) where.warehouseId = warehouseId;

    const inventory = await prisma.inventory.findMany({
      where,
      include: {
        product: { select: { id: true, sku: true, name: true } },
        location: { select: { code: true, name: true } }
      },
      orderBy: [{ bestBeforeDate: 'asc' }, { product: { sku: 'asc' } }]
    });

    const grouped = inventory.reduce((acc, inv) => {
      const key = inv.productId;
      const bbdKey = inv.bestBeforeDate ? inv.bestBeforeDate.toISOString().split('T')[0] : 'NO_BBD';
      if (!acc[key]) acc[key] = { product: inv.product, byBBD: {} };
      if (!acc[key].byBBD[bbdKey]) acc[key].byBBD[bbdKey] = { bestBeforeDate: inv.bestBeforeDate, totalQty: 0, availableQty: 0, locations: [] };
      acc[key].byBBD[bbdKey].totalQty += inv.quantity;
      acc[key].byBBD[bbdKey].availableQty += inv.availableQuantity;
      acc[key].byBBD[bbdKey].locations.push({ locationCode: inv.location?.code, quantity: inv.quantity });
      return acc;
    }, {});

    res.json({ inventory: Object.values(grouped) });
  } catch (error) {
    console.error('Error fetching inventory by BBD:', error);
    res.status(500).json({ error: 'Failed to fetch inventory by best before date' });
  }
});

// Get inventory grouped by Location
app.get('/api/inventory/by-location', verifyToken, async (req, res) => {
  try {
    const { warehouseId, locationType } = req.query;
    const where = {};
    if (warehouseId) where.warehouseId = warehouseId;

    const inventory = await prisma.inventory.findMany({
      where,
      include: {
        product: { select: { sku: true, name: true, isHeatSensitive: true, weight: true } },
        location: {
          where: locationType ? { locationType } : {},
          select: { code: true, name: true, locationType: true, pickSequence: true, maxWeight: true, isHeatSensitive: true }
        }
      },
      orderBy: [{ location: { pickSequence: 'asc' } }]
    });

    const grouped = inventory.reduce((acc, inv) => {
      if (!inv.location) return acc;
      const key = inv.locationId;
      if (!acc[key]) acc[key] = { location: inv.location, products: [], warnings: [] };
      acc[key].products.push({ product: inv.product, quantity: inv.quantity });
      if (inv.product.isHeatSensitive && inv.location.isHeatSensitive) {
        acc[key].warnings.push({ type: 'HEAT_SENSITIVE', message: 'Heat-sensitive product in hot location' });
      }
      return acc;
    }, {});

    res.json({ locations: Object.values(grouped) });
  } catch (error) {
    console.error('Error fetching inventory by location:', error);
    res.status(500).json({ error: 'Failed to fetch inventory by location' });
  }
});

// ===================================
// VAT CODES
// ===================================

app.get('/api/vat-codes', verifyToken, async (req, res) => {
  try {
    const vatCodes = await prisma.vATCode.findMany({
      include: { rates: { where: { isActive: true } } },
      orderBy: { code: 'asc' }
    });
    res.json(vatCodes);
  } catch (error) {
    res.status(500).json({ error: 'Failed to fetch VAT codes' });
  }
});

app.post('/api/vat-codes/bulk-import', verifyToken, async (req, res) => {
  try {
    const { vatCodes } = req.body;
    const results = { created: 0, updated: 0 };
    for (const vc of vatCodes) {
      const existing = await prisma.vATCode.findUnique({ where: { code: vc.code } });
      if (existing) {
        await prisma.vATCode.update({
          where: { code: vc.code },
          data: { description: vc.description, rates: { deleteMany: {}, create: vc.rates } }
        });
        results.updated++;
      } else {
        await prisma.vATCode.create({ data: { code: vc.code, description: vc.description, rates: { create: vc.rates } } });
        results.created++;
      }
    }
    res.json(results);
  } catch (error) {
    res.status(500).json({ error: 'Failed to bulk import VAT codes' });
  }
});

// ===================================
// MARKETPLACE PRICING CALCULATOR
// ===================================

app.post('/api/pricing/calculate', verifyToken, async (req, res) => {
  try {
    const { productId, channelType, consumableIds, shippingCost, laborCost, desiredMargin } = req.body;

    const product = await prisma.product.findUnique({
      where: { id: productId },
      include: { bundleItems: { include: { child: true } } }
    });

    let productCost = product.costPrice || 0;
    if (product.type === 'BUNDLE') {
      productCost = product.bundleItems.reduce((sum, item) => sum + ((item.child.costPrice || 0) * item.quantity), 0);
    }

    let consumablesCost = 0;
    if (consumableIds?.length > 0) {
      const consumables = await prisma.consumable.findMany({ where: { id: { in: consumableIds } } });
      consumablesCost = consumables.reduce((sum, c) => sum + (c.costPriceEach || 0), 0);
    }

    const totalCost = productCost + consumablesCost + (shippingCost || 0) + (laborCost || 0);
    const referralFee = 0.15; // Default 15%
    const sellingPrice = totalCost / (1 - (desiredMargin || 0) - referralFee);
    const fees = sellingPrice * referralFee;
    const profit = sellingPrice - totalCost - fees;

    res.json({
      productCost,
      consumablesCost,
      totalCost,
      recommendedSellingPrice: Math.ceil(sellingPrice * 100) / 100,
      fees,
      profit,
      margin: profit / sellingPrice
    });
  } catch (error) {
    res.status(500).json({ error: 'Failed to calculate price' });
  }
});

// ===================================
// CONSUMABLES STOCK VALUE
// ===================================

app.get('/api/consumables/stock-value', verifyToken, async (req, res) => {
  try {
    const { companyId } = req.user;
    const consumables = await prisma.consumable.findMany({
      where: { companyId, isActive: true }
    });

    let totalValue = 0;
    const breakdown = consumables.map(c => {
      const value = (c.costPricePack || 0) * Math.ceil(c.onStock / (c.unitPerPack || 1));
      totalValue += value;
      return {
        sku: c.sku,
        name: c.name,
        onStock: c.onStock,
        stockValue: value,
        needsReorder: c.reorderLevel && c.onStock <= c.reorderLevel
      };
    });

    res.json({ totalStockValue: totalValue, consumables: breakdown });
  } catch (error) {
    res.status(500).json({ error: 'Failed to calculate stock value' });
  }
});

// ===================================
// ADDITIONAL ANALYTICS ROUTES (ALIASES)
// ===================================

// Analytics channels endpoint (alias for frontend compatibility)
app.get('/api/analytics/channels', verifyToken, async (req, res) => {
  try {
    // Fetch products with channel pricing data
    const products = await prisma.product.findMany({
      where: { companyId: req.user.companyId },
      include: {
        brand: true,
        channelPrices: {
          include: {
            channel: true
          }
        },
        inventory: true
      }
    });

    // Enrich products with channel info
    const enrichedProducts = products.map(p => {
      const totalStock = p.inventory.reduce((sum, i) => sum + (i.quantity || 0), 0);
      const channelPrice = p.channelPrices[0];
      return {
        ...p,
        volume: totalStock,
        channel: channelPrice?.channel?.name || 'Direct',
        channelFee: channelPrice?.channel?.commissionRate || 0,
      };
    });

    res.json({ products: enrichedProducts });
  } catch (error) {
    console.error('Get analytics channels error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Analytics margins endpoint
app.get('/api/analytics/margins', verifyToken, async (req, res) => {
  try {
    const products = await prisma.product.findMany({
      where: { companyId: req.user.companyId },
      include: {
        brand: true,
        channelPrices: {
          include: {
            channel: true
          }
        },
        inventory: true
      }
    });

    // Calculate margin data for each product
    const productsWithMargins = products.map((p, index) => {
      const totalStock = p.inventory.reduce((sum, i) => sum + (i.quantity || 0), 0);
      const sellingPrice = p.sellingPrice || 0;
      const productCost = p.costPrice || 0;
      const packaging = sellingPrice * 0.03;
      const shipping = sellingPrice * 0.10;
      const channelPrice = p.channelPrices[0];
      const channel = channelPrice?.channel;
      const channelFee = sellingPrice * ((channel?.commissionRate || 0) / 100);
      const volume = totalStock || 0;
      const returnRate = 2.5;
      const returns = Math.floor(volume * (returnRate / 100));

      return {
        id: p.id,
        sku: p.sku,
        name: p.name,
        brand: p.brand?.name || 'Unknown',
        channel: channel?.name || 'Direct',
        category: p.brand?.name || 'General',
        sellingPrice,
        productCost,
        packaging,
        shipping,
        channelFee,
        volume,
        returns,
        returnRate,
      };
    });

    res.json({ products: productsWithMargins });
  } catch (error) {
    console.error('Get analytics margins error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Replenishment configs endpoint (plural alias)
app.get('/api/replenishment/configs', verifyToken, async (req, res) => {
  try {
    const configs = await prisma.replenishmentConfig.findMany({
      include: {
        product: {
          include: {
            brand: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });
    res.json(configs);
  } catch (error) {
    console.error('Get replenishment configs error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.post('/api/replenishment/configs', verifyToken, async (req, res) => {
  try {
    const config = await prisma.replenishmentConfig.create({
      data: req.body,
      include: {
        product: {
          include: {
            brand: true
          }
        }
      }
    });
    res.status(201).json(config);
  } catch (error) {
    console.error('Create replenishment config error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.put('/api/replenishment/configs/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const config = await prisma.replenishmentConfig.update({
      where: { id },
      data: req.body,
      include: {
        product: {
          include: {
            brand: true
          }
        }
      }
    });
    res.json(config);
  } catch (error) {
    console.error('Update replenishment config error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.delete('/api/replenishment/configs/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    await prisma.replenishmentConfig.delete({ where: { id } });
    res.json({ message: 'Configuration deleted successfully' });
  } catch (error) {
    console.error('Delete replenishment config error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// ===================================
// ADDITIONAL MISSING ROUTES
// ===================================

// Cycle counts alias (redirect to inventory/cycle-counts)
app.get('/api/cycle-counts', verifyToken, async (req, res) => {
  try {
    const cycleCounts = await prisma.cycleCount.findMany({
      where: {
        warehouse: { companyId: req.user.companyId }
      },
      include: {
        warehouse: true,
        zone: true,
        location: true,
        items: {
          include: {
            product: true
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });
    res.json(cycleCounts);
  } catch (error) {
    console.error('Get cycle counts error:', error);
    res.json([]);
  }
});

// SKU Mappings endpoint
app.get('/api/sku-mappings', verifyToken, async (req, res) => {
  try {
    const mappings = await prisma.skuMapping.findMany({
      include: {
        product: true,
        channel: true
      },
      orderBy: { createdAt: 'desc' }
    });
    res.json(mappings);
  } catch (error) {
    console.error('Get SKU mappings error:', error);
    res.json([]);
  }
});

app.post('/api/sku-mappings', verifyToken, async (req, res) => {
  try {
    const mapping = await prisma.skuMapping.create({
      data: req.body,
      include: {
        product: true,
        channel: true
      }
    });
    res.status(201).json(mapping);
  } catch (error) {
    console.error('Create SKU mapping error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.put('/api/sku-mappings/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const mapping = await prisma.skuMapping.update({
      where: { id },
      data: req.body,
      include: {
        product: true,
        channel: true
      }
    });
    res.json(mapping);
  } catch (error) {
    console.error('Update SKU mapping error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

app.delete('/api/sku-mappings/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    await prisma.skuMapping.delete({ where: { id } });
    res.json({ message: 'SKU mapping deleted successfully' });
  } catch (error) {
    console.error('Delete SKU mapping error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Scanner settings endpoint
app.get('/api/settings/scanner', verifyToken, async (req, res) => {
  try {
    // Return scanner settings (could be stored in company settings)
    const company = await prisma.company.findUnique({
      where: { id: req.user.companyId }
    });
    res.json({
      scannerEnabled: true,
      autoSubmit: true,
      soundEnabled: true,
      vibrationEnabled: true,
      barcodeFormats: ['EAN13', 'EAN8', 'CODE128', 'CODE39', 'QR'],
      cameraPreference: 'back'
    });
  } catch (error) {
    console.error('Get scanner settings error:', error);
    res.json({});
  }
});

app.post('/api/settings/scanner', verifyToken, async (req, res) => {
  try {
    // Save scanner settings
    res.json({ message: 'Scanner settings saved successfully', ...req.body });
  } catch (error) {
    console.error('Save scanner settings error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Reports list endpoint
app.get('/api/reports', verifyToken, async (req, res) => {
  try {
    // Return available reports
    res.json([
      { id: 'inventory', name: 'Inventory Report', description: 'Current inventory levels', endpoint: '/api/reports/inventory' },
      { id: 'sales', name: 'Sales Report', description: 'Sales analytics', endpoint: '/api/reports/sales' },
      { id: 'stock-movements', name: 'Stock Movements', description: 'Inventory movement history', endpoint: '/api/reports/stock-movements' },
      { id: 'stock-valuation', name: 'Stock Valuation', description: 'Value of current stock', endpoint: '/api/reports/stock-valuation' },
      { id: 'abc-analysis', name: 'ABC Analysis', description: 'Product classification analysis', endpoint: '/api/reports/abc-analysis' },
      { id: 'low-stock', name: 'Low Stock Alert', description: 'Products below reorder point', endpoint: '/api/reports/low-stock' },
      { id: 'summary', name: 'Summary Report', description: 'Overview of all reports', endpoint: '/api/reports/summary' }
    ]);
  } catch (error) {
    console.error('Get reports list error:', error);
    res.json([]);
  }
});

// Labels list endpoint
app.get('/api/labels', verifyToken, async (req, res) => {
  try {
    // Return label templates/history
    res.json([
      { id: 'product', name: 'Product Labels', description: 'Standard product barcode labels' },
      { id: 'shelf', name: 'Shelf Labels', description: 'Location/shelf labels' },
      { id: 'shipping', name: 'Shipping Labels', description: 'Order shipping labels' },
      { id: 'batch', name: 'Batch Labels', description: 'Batch/lot tracking labels' }
    ]);
  } catch (error) {
    console.error('Get labels list error:', error);
    res.json([]);
  }
});

// ===================================
// CLIENTS API
// ===================================

// Get all clients
app.get('/api/clients', verifyToken, async (req, res) => {
  try {
    const { page = 1, limit = 10, search, status } = req.query;
    const offset = (parseInt(page) - 1) * parseInt(limit);

    // Return mock data for now - in production, this would query the database
    const clients = [
      { id: 1, name: 'Client A', email: 'clienta@example.com', phone: '+1234567890', status: 'active', company: 'Company A', createdAt: new Date().toISOString() },
      { id: 2, name: 'Client B', email: 'clientb@example.com', phone: '+0987654321', status: 'active', company: 'Company B', createdAt: new Date().toISOString() },
      { id: 3, name: 'Client C', email: 'clientc@example.com', phone: '+1122334455', status: 'inactive', company: 'Company C', createdAt: new Date().toISOString() }
    ];

    res.json({
      data: clients,
      pagination: {
        page: parseInt(page),
        limit: parseInt(limit),
        total: clients.length,
        totalPages: Math.ceil(clients.length / parseInt(limit))
      }
    });
  } catch (error) {
    console.error('Get clients error:', error);
    res.status(500).json({ error: 'Failed to fetch clients' });
  }
});

// Get single client
app.get('/api/clients/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    res.json({
      id: parseInt(id),
      name: `Client ${id}`,
      email: `client${id}@example.com`,
      phone: '+1234567890',
      status: 'active',
      company: 'Company A',
      address: '123 Main St',
      city: 'New York',
      country: 'USA',
      createdAt: new Date().toISOString()
    });
  } catch (error) {
    console.error('Get client error:', error);
    res.status(500).json({ error: 'Failed to fetch client' });
  }
});

// Create client
app.post('/api/clients', verifyToken, async (req, res) => {
  try {
    const { name, email, phone, company, status } = req.body;
    const newClient = {
      id: Date.now(),
      name,
      email,
      phone,
      company,
      status: status || 'active',
      createdAt: new Date().toISOString()
    };
    res.status(201).json(newClient);
  } catch (error) {
    console.error('Create client error:', error);
    res.status(500).json({ error: 'Failed to create client' });
  }
});

// Update client
app.put('/api/clients/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, email, phone, company, status } = req.body;
    res.json({
      id: parseInt(id),
      name,
      email,
      phone,
      company,
      status,
      updatedAt: new Date().toISOString()
    });
  } catch (error) {
    console.error('Update client error:', error);
    res.status(500).json({ error: 'Failed to update client' });
  }
});

// Delete client
app.delete('/api/clients/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    res.json({ success: true, message: `Client ${id} deleted` });
  } catch (error) {
    console.error('Delete client error:', error);
    res.status(500).json({ error: 'Failed to delete client' });
  }
});

// ===================================
// ROLES API
// ===================================

// Get all roles
app.get('/api/roles', verifyToken, async (req, res) => {
  try {
    const roles = [
      { id: 1, name: 'superadmin', displayName: 'Super Admin', description: 'Full system access', permissions: ['*'], createdAt: new Date().toISOString() },
      { id: 2, name: 'company_admin', displayName: 'Company Admin', description: 'Company-level administration', permissions: ['companies.manage', 'warehouses.manage', 'users.manage'], createdAt: new Date().toISOString() },
      { id: 3, name: 'warehouse_manager', displayName: 'Warehouse Manager', description: 'Manage warehouse operations', permissions: ['warehouses.view', 'inventory.manage', 'orders.manage'], createdAt: new Date().toISOString() },
      { id: 4, name: 'packer', displayName: 'Packer', description: 'Packing and fulfillment', permissions: ['packing.manage', 'orders.view'], createdAt: new Date().toISOString() },
      { id: 5, name: 'viewer', displayName: 'Viewer', description: 'Read-only access', permissions: ['*.view'], createdAt: new Date().toISOString() }
    ];
    res.json(roles);
  } catch (error) {
    console.error('Get roles error:', error);
    res.status(500).json({ error: 'Failed to fetch roles' });
  }
});

// Get single role
app.get('/api/roles/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const roles = {
      1: { id: 1, name: 'superadmin', displayName: 'Super Admin', description: 'Full system access', permissions: ['*'] },
      2: { id: 2, name: 'company_admin', displayName: 'Company Admin', description: 'Company-level administration', permissions: ['companies.manage', 'warehouses.manage', 'users.manage'] },
      3: { id: 3, name: 'warehouse_manager', displayName: 'Warehouse Manager', description: 'Manage warehouse operations', permissions: ['warehouses.view', 'inventory.manage', 'orders.manage'] },
      4: { id: 4, name: 'packer', displayName: 'Packer', description: 'Packing and fulfillment', permissions: ['packing.manage', 'orders.view'] },
      5: { id: 5, name: 'viewer', displayName: 'Viewer', description: 'Read-only access', permissions: ['*.view'] }
    };
    const role = roles[id];
    if (!role) {
      return res.status(404).json({ error: 'Role not found' });
    }
    res.json(role);
  } catch (error) {
    console.error('Get role error:', error);
    res.status(500).json({ error: 'Failed to fetch role' });
  }
});

// Create role
app.post('/api/roles', verifyToken, async (req, res) => {
  try {
    const { name, displayName, description, permissions } = req.body;
    const newRole = {
      id: Date.now(),
      name,
      displayName,
      description,
      permissions: permissions || [],
      createdAt: new Date().toISOString()
    };
    res.status(201).json(newRole);
  } catch (error) {
    console.error('Create role error:', error);
    res.status(500).json({ error: 'Failed to create role' });
  }
});

// Update role
app.put('/api/roles/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, displayName, description, permissions } = req.body;
    res.json({
      id: parseInt(id),
      name,
      displayName,
      description,
      permissions,
      updatedAt: new Date().toISOString()
    });
  } catch (error) {
    console.error('Update role error:', error);
    res.status(500).json({ error: 'Failed to update role' });
  }
});

// Delete role
app.delete('/api/roles/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    // Prevent deletion of system roles
    const systemRoles = [1, 2, 3, 4, 5];
    if (systemRoles.includes(parseInt(id))) {
      return res.status(400).json({ error: 'Cannot delete system role' });
    }
    res.json({ success: true, message: `Role ${id} deleted` });
  } catch (error) {
    console.error('Delete role error:', error);
    res.status(500).json({ error: 'Failed to delete role' });
  }
});

// ===================================
// SHIPPING CONNECTIONS API
// ===================================

// Get shipping connections (carrier integrations)
app.get('/api/shipping/connections', verifyToken, async (req, res) => {
  try {
    const connections = [
      { id: 1, carrier: 'DHL', name: 'DHL Express', status: 'active', apiKey: '****', lastSync: new Date().toISOString() },
      { id: 2, carrier: 'FedEx', name: 'FedEx', status: 'active', apiKey: '****', lastSync: new Date().toISOString() },
      { id: 3, carrier: 'UPS', name: 'UPS', status: 'inactive', apiKey: '****', lastSync: null },
      { id: 4, carrier: 'USPS', name: 'USPS', status: 'active', apiKey: '****', lastSync: new Date().toISOString() }
    ];
    res.json(connections);
  } catch (error) {
    console.error('Get shipping connections error:', error);
    res.status(500).json({ error: 'Failed to fetch shipping connections' });
  }
});

// Create shipping connection
app.post('/api/shipping/connections', verifyToken, async (req, res) => {
  try {
    const { carrier, name, apiKey, accountNumber } = req.body;
    const newConnection = {
      id: Date.now(),
      carrier,
      name,
      apiKey: '****',
      accountNumber,
      status: 'active',
      createdAt: new Date().toISOString()
    };
    res.status(201).json(newConnection);
  } catch (error) {
    console.error('Create shipping connection error:', error);
    res.status(500).json({ error: 'Failed to create shipping connection' });
  }
});

// Update shipping connection
app.put('/api/shipping/connections/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { carrier, name, apiKey, status } = req.body;
    res.json({
      id: parseInt(id),
      carrier,
      name,
      apiKey: '****',
      status,
      updatedAt: new Date().toISOString()
    });
  } catch (error) {
    console.error('Update shipping connection error:', error);
    res.status(500).json({ error: 'Failed to update shipping connection' });
  }
});

// Delete shipping connection
app.delete('/api/shipping/connections/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    res.json({ success: true, message: `Shipping connection ${id} deleted` });
  } catch (error) {
    console.error('Delete shipping connection error:', error);
    res.status(500).json({ error: 'Failed to delete shipping connection' });
  }
});

// ===================================
// ANALYTICS PRICING OPTIMIZER API
// ===================================

// Get pricing optimizer data
app.get('/api/analytics/pricing-optimizer', verifyToken, async (req, res) => {
  try {
    const optimizerData = {
      recommendations: [
        { productId: 1, sku: 'SKU001', currentPrice: 29.99, suggestedPrice: 34.99, potentialRevenue: 500, confidence: 0.85 },
        { productId: 2, sku: 'SKU002', currentPrice: 49.99, suggestedPrice: 44.99, potentialRevenue: 300, confidence: 0.72 },
        { productId: 3, sku: 'SKU003', currentPrice: 19.99, suggestedPrice: 24.99, potentialRevenue: 250, confidence: 0.91 }
      ],
      summary: {
        totalProducts: 100,
        optimizedProducts: 45,
        potentialRevenueIncrease: 15000,
        averageMarginImprovement: 8.5
      },
      lastUpdated: new Date().toISOString()
    };
    res.json(optimizerData);
  } catch (error) {
    console.error('Get pricing optimizer error:', error);
    res.status(500).json({ error: 'Failed to fetch pricing optimizer data' });
  }
});

// Run pricing optimization
app.post('/api/analytics/pricing-optimizer/run', verifyToken, async (req, res) => {
  try {
    const { productIds, strategy } = req.body;
    res.json({
      jobId: Date.now(),
      status: 'processing',
      productsToOptimize: productIds?.length || 0,
      strategy: strategy || 'balanced',
      startedAt: new Date().toISOString()
    });
  } catch (error) {
    console.error('Run pricing optimizer error:', error);
    res.status(500).json({ error: 'Failed to run pricing optimizer' });
  }
});

// ===================================
// USERS API (Additional endpoints)
// ===================================

// Get all users
app.get('/api/users', verifyToken, async (req, res) => {
  try {
    const users = await prisma.user.findMany({
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        avatar: true,
        companyId: true,
        warehouseId: true,
        isActive: true,
        createdAt: true
      }
    });
    res.json(users);
  } catch (error) {
    console.error('Get users error:', error);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// Get single user
app.get('/api/users/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const user = await prisma.user.findUnique({
      where: { id: parseInt(id) },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        avatar: true,
        companyId: true,
        warehouseId: true,
        isActive: true,
        createdAt: true
      }
    });
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    res.json(user);
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ error: 'Failed to fetch user' });
  }
});

// Create user
app.post('/api/users', verifyToken, async (req, res) => {
  try {
    const { email, name, password, role, companyId, warehouseId } = req.body;
    const bcrypt = require('bcryptjs');
    const hashedPassword = await bcrypt.hash(password, 10);

    const user = await prisma.user.create({
      data: {
        email,
        name,
        password: hashedPassword,
        role: role || 'viewer',
        companyId: companyId ? parseInt(companyId) : null,
        warehouseId: warehouseId ? parseInt(warehouseId) : null,
        isActive: true
      },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        companyId: true,
        warehouseId: true,
        isActive: true,
        createdAt: true
      }
    });
    res.status(201).json(user);
  } catch (error) {
    console.error('Create user error:', error);
    if (error.code === 'P2002') {
      return res.status(400).json({ error: 'Email already exists' });
    }
    res.status(500).json({ error: 'Failed to create user' });
  }
});

// Update user
app.put('/api/users/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { name, role, companyId, warehouseId, isActive } = req.body;

    const user = await prisma.user.update({
      where: { id: parseInt(id) },
      data: {
        name,
        role,
        companyId: companyId ? parseInt(companyId) : null,
        warehouseId: warehouseId ? parseInt(warehouseId) : null,
        isActive
      },
      select: {
        id: true,
        email: true,
        name: true,
        role: true,
        companyId: true,
        warehouseId: true,
        isActive: true,
        updatedAt: true
      }
    });
    res.json(user);
  } catch (error) {
    console.error('Update user error:', error);
    res.status(500).json({ error: 'Failed to update user' });
  }
});

// Delete user
app.delete('/api/users/:id', verifyToken, async (req, res) => {
  try {
    const { id } = req.params;
    await prisma.user.delete({
      where: { id: parseInt(id) }
    });
    res.json({ success: true, message: `User ${id} deleted` });
  } catch (error) {
    console.error('Delete user error:', error);
    res.status(500).json({ error: 'Failed to delete user' });
  }
});

// ===================================
// INTEGRATION HEALTH & MONITORING
// ===================================

// Integration health check routes (public for monitoring systems)
app.use('/api/health', integrationHealthRouter);

// Error handling
app.use((err, req, res, next) => {
  console.error('Server error:', err);
  res.status(500).json({ error: 'Internal server error' });
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
  console.log(` WMS API Server running on port ${PORT}`);
  console.log(` Binding to 0.0.0.0 (all interfaces)`);
  console.log(` Database: PostgreSQL + Prisma`);
  console.log(` Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`\n API Endpoints:`);
  console.log(`   - Health: GET /health`);
  console.log(`   - Integration Health: GET /api/health/integrations`);
  console.log(`   - Auth: POST /api/auth/login`);
  console.log(`   - Brands: GET /api/brands`);
  console.log(`   - Products: GET /api/products`);
  console.log(`   - Inventory: GET /api/inventory`);
  console.log(`   - Orders: GET /api/sales-orders`);
  console.log(`   - Replenishment: GET /api/replenishment/tasks`);
  console.log(`   - FBA Transfers: GET /api/transfers`);
  console.log(`   - Analytics: GET /api/analytics/channel-prices`);

  // Start integration monitoring (only in production or if explicitly enabled)
  if (process.env.NODE_ENV === 'production' || process.env.ENABLE_MONITORING === 'true') {
    try {
      const monitor = getMonitor();
      monitor.start();
      console.log(`\n Integration monitoring started`);
    } catch (error) {
      console.error('Failed to start integration monitor:', error.message);
    }
  }
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  console.log('SIGTERM received, shutting down gracefully');
  try {
    const monitor = getMonitor();
    monitor.stop();
  } catch (e) { /* ignore */ }
  await prisma.$disconnect();
  process.exit(0);
});

process.on('SIGINT', async () => {
  console.log('SIGINT received, shutting down gracefully');
  try {
    const monitor = getMonitor();
    monitor.stop();
  } catch (e) { /* ignore */ }
  await prisma.$disconnect();
  process.exit(0);
});
